ê³µìœ í•˜ê¸°

User
ë‚˜ì˜ ë§:
ìŠ¤íŠ¸ë¦¼ë¦¿ìœ¼ë¡œ ì½”ë“œë¥¼ í•˜ë‚˜ì§œë ¤ê³  í•´. ë¸”ë¡œê·¸ ì‘ì„± ë„ì™€ì£¼ëŠ” íˆ´ì´ì•¼. html ë¡œ ì£¼ë“  ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ì£¼ë“  ì´ ê¸€ì„ ë¸”ë¡œê·¸ì— ë°”ë¡œ ë¶™í ìˆ˜ ìˆë„ë¡ ë„ì™€ì£¼ëŠ” í”„ë¡œê·¸ë¨ì´ê³  í•˜ë‹¨ì— ê¸€ì ìˆ˜ (ê³µë°±ì œê±°)ê°€ ë‚˜ì˜¤ëŠ”ê±°ì•¼. ê·¸ë¦¬ê³  ê¸€ìì—ì„œ ì£¼ìš” í‚¤ì›Œë“œë¥¼ ë„£ì–´ ë†“ìœ¼ë©´ í‚¤ì›Œë“œëŠ” ê¸€ìë¥¼ êµµê²Œ í•´ì£¼ëŠ” ê¸°ëŠ¥ì´ì§€. í˜¹ì‹œ ì´ëª¨í‹°ì½˜ë„ ì•Œì•„ì„œ ë“¤ì–´ê°€ê²Œ í•˜ëŠ” ê±´ í˜ë“¤ê² ì§€?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸ë¨
Streamlitìœ¼ë¡œ ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ íˆ´ì„ ë§Œë“œëŠ” ë°©ì‹ì€ ë§¤ìš° ìœ ìš©í•  ê²ƒ ê°™ì•„ìš”! ì œê°€ ì œì•ˆí•˜ëŠ” ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

ì…ë ¥ ë° í‚¤ì›Œë“œ ì„¤ì •: ì‚¬ìš©ìê°€ ê¸€ì„ ì…ë ¥í•  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ìƒìë¥¼ ì œê³µí•˜ê³ , ì£¼ìš” í‚¤ì›Œë“œë¥¼ ë³„ë„ë¡œ ì…ë ¥í•˜ê²Œ í•©ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í¬ë§·íŒ…: ì…ë ¥ëœ ê¸€ì—ì„œ ì„¤ì •í•œ í‚¤ì›Œë“œë¥¼ ì°¾ì•„ ìë™ìœ¼ë¡œ êµµê²Œ ì²˜ë¦¬í•´ ì¤ë‹ˆë‹¤. HTMLì´ë‚˜ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì œê³µí•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ì˜µì…˜ë„ ì¶”ê°€í•©ë‹ˆë‹¤.
ê¸€ì ìˆ˜ ê³„ì‚°: ì…ë ¥ëœ í…ìŠ¤íŠ¸ì˜ ê³µë°±ì„ ì œì™¸í•œ ê¸€ì ìˆ˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í•˜ë‹¨ì— í‘œì‹œí•©ë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì‚½ì…: í‚¤ì›Œë“œë‚˜ íŠ¹ì • ë‹¨ì–´ë¥¼ ê°ì§€í•˜ì—¬ ê·¸ì— ë§ëŠ” ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•˜ëŠ” ê¸°ëŠ¥ë„ ê°€ëŠ¥í•˜ì§€ë§Œ, ì´ë¥¼ ìœ„í•´ì„  í‚¤ì›Œë“œì™€ ì´ëª¨í‹°ì½˜ì„ ë§¤í•‘í•˜ëŠ” ì‚¬ì „ ëª©ë¡ì„ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤. í˜¹ì€ ê°„ë‹¨í•œ ê·œì¹™ì„ ê¸°ë°˜ìœ¼ë¡œ ì´ëª¨í‹°ì½˜ì„ ìë™ ì‚½ì…í•˜ëŠ” ë°©ë²•ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì´ì œ ê¸°ë³¸ì ì¸ ì½”ë“œë¥¼ ì œì•ˆí•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st

def bold_keywords(text, keywords):
    for keyword in keywords:
        text = text.replace(keyword, f"**{keyword}**")
    return text

def count_characters(text):
    return len(text.replace(" ", ""))

def insert_emoji(text, emoji_map):
    for word, emoji in emoji_map.items():
        text = text.replace(word, f"{word}{emoji}")
    return text

# í‚¤ì›Œë“œ ë° ì´ëª¨í‹°ì½˜ ë§¤í•‘ ì˜ˆì‹œ
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š",
    "ì„±ê³µ": "ğŸ†",
    "ê¸°ì¨": "ğŸ‰"
}

st.title("ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# ì…ë ¥ë€
input_text = st.text_area("ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)
keywords = st.text_input("ì£¼ìš” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)", "").split(",")

# í‚¤ì›Œë“œë¥¼ êµµê²Œ ì²˜ë¦¬í•œ í…ìŠ¤íŠ¸
formatted_text = bold_keywords(input_text, keywords)

# ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•œ í…ìŠ¤íŠ¸
formatted_text = insert_emoji(formatted_text, emoji_map)

# ê²°ê³¼ ì¶œë ¥
st.subheader("ë§ˆí¬ë‹¤ìš´/HTML í˜•ì‹")
st.markdown(formatted_text)

# ê¸€ì ìˆ˜ ì¶œë ¥
char_count = count_characters(input_text)
st.write(f"ê³µë°± ì œê±° ê¸€ì ìˆ˜: {char_count}ì")
ì£¼ìš” ê¸°ëŠ¥:
ê¸€ì ìˆ˜ ê³„ì‚°: ê³µë°±ì„ ì œê±°í•œ ê¸€ì ìˆ˜ê°€ ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤.
í‚¤ì›Œë“œ ê°•ì¡°: ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ì›Œë“œê°€ ìë™ìœ¼ë¡œ êµµê²Œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì‚½ì…: íŠ¹ì • ë‹¨ì–´ì— ìë™ìœ¼ë¡œ ì´ëª¨í‹°ì½˜ì´ ì¶”ê°€ë©ë‹ˆë‹¤. ì˜ˆì‹œë¡œ "í–‰ë³µ", "ì„±ê³µ", "ê¸°ì¨"ì„ í¬í•¨í–ˆìŠµë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì… ê¸°ëŠ¥ì€ ì›í•˜ëŠ” ëŒ€ë¡œ ë” ì„¸ë¶„í™”í•  ìˆ˜ ìˆìœ¼ë©°, ë‹¤ì–‘í•œ ë‹¨ì–´ì™€ ì´ëª¨í‹°ì½˜ì„ ë§¤í•‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì´ëª¨í‹°ì½˜ì´ ê°€ëŠ¥í•˜ê² ì–´?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì…ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤! ê¸°ë³¸ì ìœ¼ë¡œ Python ë¬¸ìì—´ ì²˜ë¦¬ë¥¼ í†µí•´ íŠ¹ì • í‚¤ì›Œë“œë‚˜ ë‹¨ì–´ë¥¼ ê°ì§€í•˜ë©´, ê·¸ ìë¦¬ì— ì´ëª¨í‹°ì½˜ì„ ë„£ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìœ„ ì½”ë“œì—ì„œ ë³´ì—¬ì¤€ ë°©ì‹ì²˜ëŸ¼ ë‹¨ì–´ì™€ ì´ëª¨í‹°ì½˜ì„ ë¯¸ë¦¬ ë§¤í•‘í•´ ë‘ë©´, í•´ë‹¹ ë‹¨ì–´ê°€ í¬í•¨ëœ í…ìŠ¤íŠ¸ì— ìë™ìœ¼ë¡œ ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ìš”.

ì˜ˆë¥¼ ë“¤ì–´, ì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸ì—ì„œ "í–‰ë³µ"ì´ë¼ëŠ” ë‹¨ì–´ë¥¼ ì°¾ì•„ ğŸ˜Š ì´ëª¨í‹°ì½˜ì„ ì‚½ì…í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ë§Œ, ì´ë¥¼ ì¢€ ë” ë°œì „ì‹œí‚¤ê³  ì‹¶ë‹¤ë©´ ì‚¬ìš©ìê°€ ì…ë ¥í•˜ëŠ” í‚¤ì›Œë“œì— ë”°ë¼ ì´ëª¨í‹°ì½˜ì„ ì§ì ‘ ì„¤ì •í•˜ê±°ë‚˜, íŠ¹ì • ìƒí™©ì— ë§ëŠ” ì´ëª¨í‹°ì½˜ì„ ì¶”ì²œí•´ì£¼ëŠ” ê¸°ëŠ¥ë„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëª¨í‹°ì½˜ ê¸°ëŠ¥ ê°œì„  ì•„ì´ë””ì–´:
ë‹¨ì–´-ì´ëª¨í‹°ì½˜ ì‚¬ì „: ë‹¤ì–‘í•œ ë‹¨ì–´ì™€ ì´ëª¨í‹°ì½˜ì„ ë§¤í•‘í•´ ë‘ê³ , í•´ë‹¹ ë‹¨ì–´ê°€ í…ìŠ¤íŠ¸ì— ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ì´ëª¨í‹°ì½˜ì„ ë„£ìŠµë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì¶”ì²œ: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê¸€ì—ì„œ ê°ì •ì„ ë¶„ì„í•´, ê´€ë ¨ëœ ì´ëª¨í‹°ì½˜ì„ ì¶”ì²œí•˜ëŠ” ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ì„ í™œìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ëŠ” êµ¬í˜„ì´ ì¡°ê¸ˆ ë” ë³µì¡í•´ì§‘ë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì‚½ì… ê¸°ëŠ¥ì€ Streamlitì—ì„œ ì˜ ì‘ë™í•˜ë©°, ë³¸ì¸ì´ ì›í•˜ëŠ” ì´ëª¨í‹°ì½˜ì„ ììœ ë¡­ê²Œ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆì–´ ë§¤ìš° ìœ ìš©í•  ê²ƒì…ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ê·¸ëŸ¼ ìì£¼ì“°ëŠ” ì´ëª¨í‹°ì½˜ ì•„ì£¼ ë§ì´ ë„£ì–´ì¤˜. ì•„ì˜ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë”°ë¡œ ë§Œë“¤ì–´ ì£¼ë˜ê°€
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë§ì´ ì‚¬ìš©í•˜ëŠ” ì´ëª¨í‹°ì½˜ë“¤ì„ ë¯¸ë¦¬ ì„¤ì •í•´ ë‘ë©´, ë‹¤ì–‘í•œ í…ìŠ¤íŠ¸ì— ìë™ìœ¼ë¡œ ì ìš©í•  ìˆ˜ ìˆì„ ê±°ì˜ˆìš”. ì•„ë˜ëŠ” ìì£¼ ì“°ì´ëŠ” ì´ëª¨í‹°ì½˜ë“¤ì„ í…Œë§ˆë³„ë¡œ ë‚˜ëˆˆ ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì´ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ í…ìŠ¤íŠ¸ì— ì´ëª¨í‹°ì½˜ì„ ì‚½ì…í•  ìˆ˜ ìˆë„ë¡ ì ìš©í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìì£¼ ì“°ëŠ” ì´ëª¨í‹°ì½˜ ë¦¬ìŠ¤íŠ¸
ê°ì • í‘œí˜„:

ğŸ˜Š : í–‰ë³µ
ğŸ˜¢ : ìŠ¬í””
ğŸ˜¡ : í™”ë‚¨
ğŸ˜ : ì‚¬ë‘
ğŸ¤” : ìƒê°
ğŸ˜‚ : ì›ƒìŒ
ğŸ˜­ : ìš¸ìŒ
ğŸ˜œ : ì¥ë‚œ
ğŸ˜ : ë©‹ì§
ì¶•í•˜/ì„±ê³µ:

ğŸ‰ : ì¶•í•˜
ğŸ† : ì„±ê³µ
ğŸ¥‡ : 1ë“±
ğŸ‘ : ë°•ìˆ˜
ğŸŒŸ : ë³„
ğŸ¥³ : íŒŒí‹°
ì¼ìƒ/ìƒí™œ:

ğŸ½ : ìŒì‹
â˜• : ì»¤í”¼
ğŸº : ë§¥ì£¼
ğŸ  : ì§‘
ğŸ› : ì 
ğŸš— : ìë™ì°¨
âœˆï¸ : ë¹„í–‰ê¸°
ğŸ’¼ : ì¼
ìì—°/í™˜ê²½:

ğŸŒ : í•´
ğŸŒ§ : ë¹„
â›„ : ëˆˆ
ğŸŒ¸ : ê½ƒ
ğŸŒ² : ë‚˜ë¬´
ğŸŒŠ : ë¬¼
ğŸ¶ : ê°œ
ğŸ± : ê³ ì–‘ì´
ì†Œì…œ ë¯¸ë””ì–´:

â¤ï¸ : ì‚¬ë‘
ğŸ‘ : ì¢‹ì•„ìš”
ğŸ‘ : ì‹«ì–´ìš”
ğŸ’¬ : ëŒ€í™”
ğŸ“¸ : ì‚¬ì§„
ğŸ¥ : ë¹„ë””ì˜¤
ì‹œê°„:

â° : ì‹œê°„
ğŸ“… : ë‹¬ë ¥
â³ : ëª¨ë˜ì‹œê³„
ì´ëª¨í‹°ì½˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì½”ë“œì— ì ìš©í•˜ê¸°
ì•„ë˜ì²˜ëŸ¼ ì´ ì´ëª¨í‹°ì½˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ì— ìë™ìœ¼ë¡œ ì‚½ì…í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

python
ì½”ë“œ ë³µì‚¬
import streamlit as st

# ìì£¼ ì“°ëŠ” ì´ëª¨í‹°ì½˜ ë§¤í•‘
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š", "ìŠ¬í””": "ğŸ˜¢", "í™”ë‚¨": "ğŸ˜¡", "ì‚¬ë‘": "ğŸ˜", "ìƒê°": "ğŸ¤”", "ì›ƒìŒ": "ğŸ˜‚", "ìš¸ìŒ": "ğŸ˜­", "ì¥ë‚œ": "ğŸ˜œ", "ë©‹ì§": "ğŸ˜",
    "ì¶•í•˜": "ğŸ‰", "ì„±ê³µ": "ğŸ†", "1ë“±": "ğŸ¥‡", "ë°•ìˆ˜": "ğŸ‘", "ë³„": "ğŸŒŸ", "íŒŒí‹°": "ğŸ¥³",
    "ìŒì‹": "ğŸ½", "ì»¤í”¼": "â˜•", "ë§¥ì£¼": "ğŸº", "ì§‘": "ğŸ ", "ì ": "ğŸ›", "ìë™ì°¨": "ğŸš—", "ë¹„í–‰ê¸°": "âœˆï¸", "ì¼": "ğŸ’¼",
    "í•´": "ğŸŒ", "ë¹„": "ğŸŒ§", "ëˆˆ": "â›„", "ê½ƒ": "ğŸŒ¸", "ë‚˜ë¬´": "ğŸŒ²", "ë¬¼": "ğŸŒŠ", "ê°œ": "ğŸ¶", "ê³ ì–‘ì´": "ğŸ±",
    "ì‚¬ë‘í•´": "â¤ï¸", "ì¢‹ì•„ìš”": "ğŸ‘", "ì‹«ì–´ìš”": "ğŸ‘", "ëŒ€í™”": "ğŸ’¬", "ì‚¬ì§„": "ğŸ“¸", "ë¹„ë””ì˜¤": "ğŸ¥",
    "ì‹œê°„": "â°", "ë‹¬ë ¥": "ğŸ“…", "ëª¨ë˜ì‹œê³„": "â³"
}

# ì´ëª¨í‹°ì½˜ ì‚½ì… í•¨ìˆ˜
def insert_emoji(text, emoji_map):
    for word, emoji in emoji_map.items():
        text = text.replace(word, f"{word}{emoji}")
    return text

st.title("ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# ì…ë ¥ë€
input_text = st.text_area("ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)
keywords = st.text_input("ì£¼ìš” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)", "").split(",")

# ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•œ í…ìŠ¤íŠ¸
formatted_text = insert_emoji(input_text, emoji_map)

# ê²°ê³¼ ì¶œë ¥
st.subheader("ì´ëª¨í‹°ì½˜ ì¶”ê°€ëœ í…ìŠ¤íŠ¸")
st.markdown(formatted_text)

# ê¸€ì ìˆ˜ ì¶œë ¥
char_count = len(input_text.replace(" ", ""))
st.write(f"ê³µë°± ì œê±° ê¸€ì ìˆ˜: {char_count}ì")
ì£¼ìš” ê¸°ëŠ¥:
ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì…: í…ìŠ¤íŠ¸ì—ì„œ íŠ¹ì • í‚¤ì›Œë“œë¥¼ ê°ì§€í•˜ì—¬ ì´ëª¨í‹°ì½˜ì„ ìë™ìœ¼ë¡œ ì‚½ì…í•©ë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ë¦¬ìŠ¤íŠ¸ í™•ì¥ ê°€ëŠ¥: ìì£¼ ì‚¬ìš©í•˜ëŠ” ì´ëª¨í‹°ì½˜ë“¤ì„ ì‰½ê²Œ ì¶”ê°€í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì‹¤ì‹œê°„ ì²˜ë¦¬: ì…ë ¥í•˜ëŠ” ì¦‰ì‹œ ì´ëª¨í‹°ì½˜ì´ ìë™ìœ¼ë¡œ ì‚½ì…ë˜ì–´ ë³´ì—¬ì§‘ë‹ˆë‹¤.
ì´ë ‡ê²Œ í•˜ë©´ ë¸”ë¡œê·¸ ì‘ì„± ì¤‘ì— íŠ¹ì • ë‹¨ì–´ë‚˜ ë¬¸êµ¬ì— ë§ëŠ” ì´ëª¨í‹°ì½˜ì´ ìë™ìœ¼ë¡œ ë“¤ì–´ê°€ëŠ” ê¸°ëŠ¥ì„ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•„ìš”ì— ë”°ë¼ ì´ëª¨í‹°ì½˜ ë§¤í•‘ì„ ë” í™•ì¥í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ë¸”ë¡œê·¸ ê¸€ë„ í¬ê²Œ ë„£ì„ ìˆ˜ ìˆë„ë¡ ì…ë ¥ì°½ë„ ê½¤ ë„“ê³  ê¸¸ê²Œ ë§Œë“¤ì
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë¸”ë¡œê·¸ ê¸€ì„ ë” ê¸¸ê³  í¸í•˜ê²Œ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡, ì…ë ¥ì°½ì„ ë„“ê³  ê¸¸ê²Œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Streamlitì˜ text_areaì—ì„œ heightì™€ width ê°’ì„ ì¡°ì •í•˜ë©´ ì…ë ¥ì°½ì„ ììœ ë¡­ê²Œ í™•ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Streamlitì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ width ì˜µì…˜ì„ ì œê³µí•˜ì§€ ì•Šì§€ë§Œ, í™”ë©´ ë°°ì¹˜ ì¡°ì •ì„ í†µí•´ ì „ì²´ í˜ì´ì§€ë¥¼ ìµœëŒ€í•œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìˆ˜ì •ëœ ì½”ë“œ (ì…ë ¥ì°½ í™•ì¥)
python
ì½”ë“œ ë³µì‚¬
import streamlit as st

# ìì£¼ ì“°ëŠ” ì´ëª¨í‹°ì½˜ ë§¤í•‘
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š", "ìŠ¬í””": "ğŸ˜¢", "í™”ë‚¨": "ğŸ˜¡", "ì‚¬ë‘": "ğŸ˜", "ìƒê°": "ğŸ¤”", "ì›ƒìŒ": "ğŸ˜‚", "ìš¸ìŒ": "ğŸ˜­", "ì¥ë‚œ": "ğŸ˜œ", "ë©‹ì§": "ğŸ˜",
    "ì¶•í•˜": "ğŸ‰", "ì„±ê³µ": "ğŸ†", "1ë“±": "ğŸ¥‡", "ë°•ìˆ˜": "ğŸ‘", "ë³„": "ğŸŒŸ", "íŒŒí‹°": "ğŸ¥³",
    "ìŒì‹": "ğŸ½", "ì»¤í”¼": "â˜•", "ë§¥ì£¼": "ğŸº", "ì§‘": "ğŸ ", "ì ": "ğŸ›", "ìë™ì°¨": "ğŸš—", "ë¹„í–‰ê¸°": "âœˆï¸", "ì¼": "ğŸ’¼",
    "í•´": "ğŸŒ", "ë¹„": "ğŸŒ§", "ëˆˆ": "â›„", "ê½ƒ": "ğŸŒ¸", "ë‚˜ë¬´": "ğŸŒ²", "ë¬¼": "ğŸŒŠ", "ê°œ": "ğŸ¶", "ê³ ì–‘ì´": "ğŸ±",
    "ì‚¬ë‘í•´": "â¤ï¸", "ì¢‹ì•„ìš”": "ğŸ‘", "ì‹«ì–´ìš”": "ğŸ‘", "ëŒ€í™”": "ğŸ’¬", "ì‚¬ì§„": "ğŸ“¸", "ë¹„ë””ì˜¤": "ğŸ¥",
    "ì‹œê°„": "â°", "ë‹¬ë ¥": "ğŸ“…", "ëª¨ë˜ì‹œê³„": "â³"
}

# ì´ëª¨í‹°ì½˜ ì‚½ì… í•¨ìˆ˜
def insert_emoji(text, emoji_map):
    for word, emoji in emoji_map.items():
        text = text.replace(word, f"{word}{emoji}")
    return text

# Streamlit ë ˆì´ì•„ì›ƒ ì„¤ì • (ì „ì²´ í™”ë©´ ì‚¬ìš©)
st.set_page_config(layout="wide")

st.title("ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# ì…ë ¥ë€ (ë„“ê³  ê¸¸ê²Œ ì„¤ì •)
input_text = st.text_area("ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=600, placeholder="ì—¬ê¸°ì— ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...")  # Height ì¡°ì •

# í‚¤ì›Œë“œ ì…ë ¥
keywords = st.text_input("ì£¼ìš” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)", "").split(",")

# ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•œ í…ìŠ¤íŠ¸
formatted_text = insert_emoji(input_text, emoji_map)

# ê²°ê³¼ ì¶œë ¥
st.subheader("ì´ëª¨í‹°ì½˜ ì¶”ê°€ëœ í…ìŠ¤íŠ¸")
st.markdown(formatted_text)

# ê¸€ì ìˆ˜ ì¶œë ¥
char_count = len(input_text.replace(" ", ""))
st.write(f"ê³µë°± ì œê±° ê¸€ì ìˆ˜: {char_count}ì")
ì£¼ìš” ë³€ê²½ ì‚¬í•­:
st.set_page_config(layout="wide"): ì´ ì„¤ì •ì„ í†µí•´ í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ "wide"ë¡œ ë³€ê²½í•˜ì—¬ í™”ë©´ ì „ì²´ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì…ë ¥ì°½ì´ í›¨ì”¬ ë„“ì–´ì§€ë©° ê¸´ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ê¸° ë” í¸ë¦¬í•´ì§‘ë‹ˆë‹¤.
ì…ë ¥ì°½ í¬ê¸°: text_areaì˜ height ê°’ì„ 600ìœ¼ë¡œ ì„¤ì •í•´, ê¸´ ê¸€ì„ í¸ì•ˆí•˜ê²Œ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•„ìš”ì— ë”°ë¼ ì´ ê°’ì„ ë” ì¡°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì´ë ‡ê²Œ í•˜ë©´ ë¸”ë¡œê·¸ ê¸€ì„ ê¸¸ê³  ë„“ê²Œ ì‘ì„±í•  ìˆ˜ ìˆëŠ” í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
import streamlit as st
import urllib.request
import json
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64
import concurrent.futures

# ì‚¬ìš©ì ì…ë ¥ ë¶€ë¶„ì„ Streamlitìœ¼ë¡œ ë³€ê²½
st.title('Naver Keyword Analysis Tool')

# st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ì…ë ¥
keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')

BASE_URL = 'https://api.naver.com'

class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = "{}.{}.{}".format(timestamp, method, uri)
        hash = hmac.new(bytes(secret_key, "utf-8"), bytes(message, "utf-8"), hashlib.sha256)
        return base64.b64encode(hash.digest())

def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ë¬¸ì„œ ìˆ˜ ê²€ìƒ‰ í•¨ìˆ˜
def get_total_docs(keyword):
    try:
        encText = urllib.parse.quote(keyword)
        url = f"https://openapi.naver.com/v1/search/webkr.json?query={encText}"
        request = urllib.request.Request(url)
        request.add_header("X-Naver-Client-Id", client_id)
        request.add_header("X-Naver-Client-Secret", client_secret)

        # íƒ€ì„ì•„ì›ƒ ì„¤ì •
        with urllib.request.urlopen(request, timeout=10) as response:
            rescode = response.getcode()

            if rescode == 200:
                response_body = response.read()
                text = response_body.decode('utf-8')
                return json.loads(text)['total']
            else:
                st.error(f"Error Code {rescode} for keyword: {keyword}")
                return 0
    except urllib.error.HTTPError as e:
        st.error(f"HTTPError: {e.code} for keyword: {keyword}")
        return 0
    except urllib.error.URLError as e:
        st.error(f"URLError: {e.reason} for keyword: {keyword}")
        return 0
    except Exception as e:
        st.error(f"Exception: {str(e)} for keyword: {keyword}")
        return 0

# Streamlit button for running analysis
if st.button('ë¶„ì„ ì‹¤í–‰'):
    tmp_df = pd.DataFrame()

    with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
        for keyword in keywords:
            keyword = keyword.strip()  # Trim whitespace
            df = get_keyword_analysis(keyword)
            tmp_df = pd.concat([tmp_df, df], axis=0)

    if not tmp_df.empty:
        # 'ì—°ê´€í‚¤ì›Œë“œ' ê°œìˆ˜ ì¶œë ¥
        st.write(f"ì—°ê´€í‚¤ì›Œë“œ ê°œìˆ˜: {len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ'])}")

        # Progress bar for document search
        progress_bar = st.progress(0)
        progress_text = st.empty()

        # ë³‘ë ¬ ì²˜ë¦¬ë¡œ ë¬¸ì„œ ê²€ìƒ‰ ìˆ˜í–‰
        with concurrent.futures.ThreadPoolExecutor() as executor:
            total_docs = list(executor.map(get_total_docs, tmp_df['ì—°ê´€í‚¤ì›Œë“œ']))

        tmp_df['ì´ë¬¸ì„œìˆ˜'] = total_docs
        tmp_df['ê²½ìŸì •ë„_ratio'] = tmp_df['ì´ë¬¸ì„œìˆ˜'] / tmp_df['ì´ê²€ìƒ‰ìˆ˜']

        # Progress ì—…ë°ì´íŠ¸
        for i, word in enumerate(tmp_df['ì—°ê´€í‚¤ì›Œë“œ']):
            progress_bar.progress((i + 1) / len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ']))
            progress_text.text(f"ë¬¸ì„œ ê²€ìƒ‰ ì§„í–‰ ì¤‘... ({i + 1}/{len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ'])})")

        # Display final dataframe
        st.write(tmp_df)

        # ê²½ìŸì •ë„ê°€ ì‘ê³ , ëª¨ë°”ì¼ ê²€ìƒ‰ì´ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
        recommended_df = tmp_df.sort_values(by=['ê²½ìŸì •ë„', 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼'], ascending=[True, False])

        # ì¶”ì²œ ëª©ë¡ì„ í‘œë¡œ í‘œì‹œ
        st.subheader('ì¶”ì²œ í‚¤ì›Œë“œ (ê²½ìŸì •ë„ê°€ ë‚®ê³  ëª¨ë°”ì¼ ê²€ìƒ‰ì´ ë†’ì€ ìˆœì„œ)')
        st.write(recommended_df[['ì—°ê´€í‚¤ì›Œë“œ', 'ê²½ìŸì •ë„', 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']].head(10))  # ìƒìœ„ 10ê°œì˜ ì¶”ì²œ í‚¤ì›Œë“œ

        # Provide a download link for the resulting dataframe
        csv = tmp_df.to_csv(index=False).encode('utf-8')
        st.download_button("CSV ë‹¤ìš´ë¡œë“œ", data=csv, file_name='keyword_analysis.csv', mime='text/csv') í‚¤ì›Œë“œë¥¼ ë„£ìœ¼ë©´ ì´ ì½”ë“œë„ ê°™ì´ ì‹¤í–‰í•´ì„œ ê²°ê³¼ ê°’ì„ ë³´ì—¬ ì£¼ê³  ê¸€ì„ ì‘ì„±í• ë•Œ ìœ ìš©í•˜ê²Œ í•˜ì
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì´ ì½”ë“œì— ì¶”ê°€ëœ í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥ì„ ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ íˆ´ì— í†µí•©í•˜ì—¬ ìœ ìš©í•œ ê²°ê³¼ ê°’ì„ ë³´ì—¬ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ì™€ ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì… ê¸°ëŠ¥ì„ ë™ì‹œì— ì œê³µí•˜ë©´, ì‚¬ìš©ìëŠ” í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ë³´ê³  ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ì‹œ ë”ìš± ì „ëµì ì¸ ì„ íƒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í†µí•©ëœ ì½”ë“œ ì˜ˆì‹œ:
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import urllib.request
import json
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64
import concurrent.futures

# ìì£¼ ì“°ëŠ” ì´ëª¨í‹°ì½˜ ë§¤í•‘
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š", "ìŠ¬í””": "ğŸ˜¢", "í™”ë‚¨": "ğŸ˜¡", "ì‚¬ë‘": "ğŸ˜", "ìƒê°": "ğŸ¤”", "ì›ƒìŒ": "ğŸ˜‚", "ìš¸ìŒ": "ğŸ˜­", "ì¥ë‚œ": "ğŸ˜œ", "ë©‹ì§": "ğŸ˜",
    "ì¶•í•˜": "ğŸ‰", "ì„±ê³µ": "ğŸ†", "1ë“±": "ğŸ¥‡", "ë°•ìˆ˜": "ğŸ‘", "ë³„": "ğŸŒŸ", "íŒŒí‹°": "ğŸ¥³",
    "ìŒì‹": "ğŸ½", "ì»¤í”¼": "â˜•", "ë§¥ì£¼": "ğŸº", "ì§‘": "ğŸ ", "ì ": "ğŸ›", "ìë™ì°¨": "ğŸš—", "ë¹„í–‰ê¸°": "âœˆï¸", "ì¼": "ğŸ’¼",
    "í•´": "ğŸŒ", "ë¹„": "ğŸŒ§", "ëˆˆ": "â›„", "ê½ƒ": "ğŸŒ¸", "ë‚˜ë¬´": "ğŸŒ²", "ë¬¼": "ğŸŒŠ", "ê°œ": "ğŸ¶", "ê³ ì–‘ì´": "ğŸ±",
    "ì‚¬ë‘í•´": "â¤ï¸", "ì¢‹ì•„ìš”": "ğŸ‘", "ì‹«ì–´ìš”": "ğŸ‘", "ëŒ€í™”": "ğŸ’¬", "ì‚¬ì§„": "ğŸ“¸", "ë¹„ë””ì˜¤": "ğŸ¥",
    "ì‹œê°„": "â°", "ë‹¬ë ¥": "ğŸ“…", "ëª¨ë˜ì‹œê³„": "â³"
}

# ì´ëª¨í‹°ì½˜ ì‚½ì… í•¨ìˆ˜
def insert_emoji(text, emoji_map):
    for word, emoji in emoji_map.items():
        text = text.replace(word, f"{word}{emoji}")
    return text

# Streamlit ë ˆì´ì•„ì›ƒ ì„¤ì • (ì „ì²´ í™”ë©´ ì‚¬ìš©)
st.set_page_config(layout="wide")

st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ + í‚¤ì›Œë“œ ë¶„ì„ íˆ´')

# í‚¤ì›Œë“œ ë¶„ì„ ì„¤ì •
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ì…ë ¥ (í…ìŠ¤íŠ¸ ì‘ì„± ë° í‚¤ì›Œë“œ ë¶„ì„ í†µí•©)
keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš” (ì—¬ê¸°ì— í…ìŠ¤íŠ¸ ì…ë ¥)", height=600).strip()

BASE_URL = 'https://api.naver.com'

class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = "{}.{}.{}".format(timestamp, method, uri)
        hash = hmac.new(bytes(secret_key, "utf-8"), bytes(message, "utf-8"), hashlib.sha256)
        return base64.b64encode(hash.digest())

def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

def get_total_docs(keyword):
    try:
        encText = urllib.parse.quote(keyword)
        url = f"https://openapi.naver.com/v1/search/webkr.json?query={encText}"
        request = urllib.request.Request(url)
        request.add_header("X-Naver-Client-Id", client_id)
        request.add_header("X-Naver-Client-Secret", client_secret)

        with urllib.request.urlopen(request, timeout=10) as response:
            rescode = response.getcode()

            if rescode == 200:
                response_body = response.read()
                text = response_body.decode('utf-8')
                return json.loads(text)['total']
            else:
                st.error(f"Error Code {rescode} for keyword: {keyword}")
                return 0
    except urllib.error.HTTPError as e:
        st.error(f"HTTPError: {e.code} for keyword: {keyword}")
        return 0
    except urllib.error.URLError as e:
        st.error(f"URLError: {e.reason} for keyword: {keyword}")
        return 0
    except Exception as e:
        st.error(f"Exception: {str(e)} for keyword: {keyword}")
        return 0

# ë¶„ì„ ë²„íŠ¼
if st.button('ë¶„ì„ ì‹¤í–‰'):
    tmp_df = pd.DataFrame()

    with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
        for keyword in keywords:
            keyword = keyword.strip()
            df = get_keyword_analysis(keyword)
            tmp_df = pd.concat([tmp_df, df], axis=0)

    if not tmp_df.empty:
        st.write(f"ì—°ê´€í‚¤ì›Œë“œ ê°œìˆ˜: {len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ'])}")

        progress_bar = st.progress(0)
        progress_text = st.empty()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            total_docs = list(executor.map(get_total_docs, tmp_df['ì—°ê´€í‚¤ì›Œë“œ']))

        tmp_df['ì´ë¬¸ì„œìˆ˜'] = total_docs
        tmp_df['ê²½ìŸì •ë„_ratio'] = tmp_df['ì´ë¬¸ì„œìˆ˜'] / tmp_df['ì´ê²€ìƒ‰ìˆ˜']

        for i, word in enumerate(tmp_df['ì—°ê´€í‚¤ì›Œë“œ']):
            progress_bar.progress((i + 1) / len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ']))
            progress_text.text(f"ë¬¸ì„œ ê²€ìƒ‰ ì§„í–‰ ì¤‘... ({i + 1}/{len(tmp_df['ì—°ê´€í‚¤ì›Œë“œ'])})")

        st.write(tmp_df)

        recommended_df = tmp_df.sort_values(by=['ê²½ìŸì •ë„', 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼'], ascending=[True, False])

        st.subheader('ì¶”ì²œ í‚¤ì›Œë“œ (ê²½ìŸì •ë„ê°€ ë‚®ê³  ëª¨ë°”ì¼ ê²€ìƒ‰ì´ ë†’ì€ ìˆœì„œ)')
        st.write(recommended_df[['ì—°ê´€í‚¤ì›Œë“œ', 'ê²½ìŸì •ë„', 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']].head(10))

        csv = tmp_df.to_csv(index=False).encode('utf-8')
        st.download_button("CSV ë‹¤ìš´ë¡œë“œ", data=csv, file_name='keyword_analysis.csv', mime='text/csv')

# ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ ê¸°ëŠ¥ (ì´ëª¨í‹°ì½˜ ì‚½ì…)
if input_text:
    formatted_text = insert_emoji(input_text, emoji_map)
    st.subheader("ì´ëª¨í‹°ì½˜ ì¶”ê°€ëœ í…ìŠ¤íŠ¸")
    st.markdown(formatted_text)

    char_count = len(input_text.replace(" ", ""))
    st.write(f"ê³µë°± ì œê±° ê¸€ì ìˆ˜: {char_count}ì")
ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…:
í‚¤ì›Œë“œ ë¶„ì„: ì…ë ¥ëœ í‚¤ì›Œë“œì— ëŒ€í•œ ë„¤ì´ë²„ ê´‘ê³  API ë¶„ì„ ê¸°ëŠ¥ê³¼ ì—°ê´€ í‚¤ì›Œë“œë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤.
ë¬¸ì„œ ìˆ˜ ê²€ìƒ‰: ì—°ê´€ í‚¤ì›Œë“œì— ëŒ€í•œ ì›¹ë¬¸ì„œ ìˆ˜ë¥¼ ê²€ìƒ‰í•˜ì—¬ ê²½ìŸ ì •ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ì§€ì›: ì‚¬ìš©ìê°€ ì‘ì„±í•œ ë¸”ë¡œê·¸ ê¸€ì— ìì£¼ ì‚¬ìš©í•˜ëŠ” ì´ëª¨í‹°ì½˜ì„ ìë™ìœ¼ë¡œ ì‚½ì…í•˜ê³  ê¸€ì ìˆ˜ë¥¼ ê³„ì‚°í•´ ë³´ì—¬ì¤ë‹ˆë‹¤.
ì´ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ë¸”ë¡œê·¸ ì‘ì„±ê³¼ í‚¤ì›Œë“œ ë¶„ì„ì„ ë™ì‹œì— í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë„êµ¬ë¡œ ë°œì „í•˜ê²Œ ë©ë‹ˆë‹¤!

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
êµ¬ê¸€ ê´‘ê³ í‚¤ì›Œë“œë„ ë„£ê³  ì‹¶ì€ë°, êµ¬ê¸€ ê´‘ê³  í‚¤ì›Œë“œ ë²„íŠ¼ì„ 3ê°œê°€ ìˆê³  ê°ê° ëˆ„ë¥´ë©´ <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
     crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>  ë˜ëŠ” <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
     crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script> ë˜ëŠ” <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
     crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script> ì½”ë“œê°€ ìë™ ë³µì‚¬ë˜ì–´ì„œ ë¶™í˜€ë„£ê¸° í•˜ë©´ ë°”ë¡œ ë¶™í˜€ë„£ê¸° í•  ìˆ˜ ìˆë„ë¡ í•´ì¤˜. ì´ëŸ° ê¸°ëŠ¥ë“¤ì€ ê¸€ì„ ì‘ì„±í•  ë•Œ ì‘ì„±ë˜ëŠ” ë€ì´ ì—†ì–´ì§€ë©´ ì•ˆë˜ë‹ˆê¹Œ ì˜ ê³ ë ¤í•´ì„œ ì‘ì„±í•´ì¤˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
êµ¬ê¸€ ê´‘ê³  í‚¤ì›Œë“œë¥¼ ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ë„êµ¬ì— ì¶”ê°€í•˜ëŠ” ë°©ë²•ìœ¼ë¡œëŠ”, ê°ê°ì˜ ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œë¥¼ ì œê³µí•˜ëŠ” ë²„íŠ¼ì„ 3ê°œ ë§Œë“¤ê³ , ê° ë²„íŠ¼ì„ í´ë¦­í–ˆì„ ë•Œ í•´ë‹¹ ì½”ë“œê°€ ìë™ìœ¼ë¡œ ë³µì‚¬ë˜ë„ë¡ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œ ê¸€ ì‘ì„±ë€ì´ ì‚¬ë¼ì§€ì§€ ì•Šë„ë¡, ë³„ë„ì˜ ì˜ì—­ì—ì„œ ë³µì‚¬ ê¸°ëŠ¥ì´ ë™ì‘í•˜ê²Œ í•´ì•¼ í•©ë‹ˆë‹¤.

ì•„ë˜ëŠ” Streamlit ì•±ì— ë³µì‚¬ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤. pyperclip ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Streamlit ìì²´ì ìœ¼ë¡œëŠ” í´ë¦½ë³´ë“œ ë³µì‚¬ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, HTMLì„ í™œìš©í•œ JavaScript ì½”ë“œë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì½”ë“œ ì˜ˆì‹œ:
python
ì½”ë“œ ë³µì‚¬
import streamlit as st

# Google Ads Script ë°ì´í„°
ads_scripts = {
    "êµ¬ë¼ë‹¤ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¸”ë¡œê·¸ìŠ¤íŒŸ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¯¸ë¼í´E ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>'''
}

# Streamlit ë ˆì´ì•„ì›ƒ ì„¤ì • (ì „ì²´ í™”ë©´ ì‚¬ìš©)
st.set_page_config(layout="wide")

st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ ë° Google Ads ìŠ¤í¬ë¦½íŠ¸ ì œê³µ')

# ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ë€
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300).strip()

# ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ ë²„íŠ¼ë“¤
st.subheader("Google ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬")
for ad_name, ad_script in ads_scripts.items():
    st.code(ad_script, language="html")
    st.markdown(f'<button class="copy-button" onclick="copyToClipboard(`{ad_script}`)">ğŸ“‹ {ad_name} ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬</button>', unsafe_allow_html=True)

# JavaScriptë¥¼ ì‚¬ìš©í•˜ì—¬ í´ë¦½ë³´ë“œ ë³µì‚¬ ê¸°ëŠ¥ êµ¬í˜„
copy_js = """
<script>
    function copyToClipboard(text) {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        alert("ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
    }
</script>
"""
st.markdown(copy_js, unsafe_allow_html=True)

# ì´ëª¨í‹°ì½˜ ì‚½ì… ë° ê¸€ì ìˆ˜ ê³„ì‚°
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š", "ìŠ¬í””": "ğŸ˜¢", "í™”ë‚¨": "ğŸ˜¡", "ì‚¬ë‘": "ğŸ˜", "ìƒê°": "ğŸ¤”", "ì›ƒìŒ": "ğŸ˜‚", "ìš¸ìŒ": "ğŸ˜­", "ì¥ë‚œ": "ğŸ˜œ", "ë©‹ì§": "ğŸ˜",
    "ì¶•í•˜": "ğŸ‰", "ì„±ê³µ": "ğŸ†", "1ë“±": "ğŸ¥‡", "ë°•ìˆ˜": "ğŸ‘", "ë³„": "ğŸŒŸ", "íŒŒí‹°": "ğŸ¥³",
    "ìŒì‹": "ğŸ½", "ì»¤í”¼": "â˜•", "ë§¥ì£¼": "ğŸº", "ì§‘": "ğŸ ", "ì ": "ğŸ›", "ìë™
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì „ì²´ ì½”ë“œë¥¼ ì œê³µí•´ì¤˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” Streamlitì„ ì‚¬ìš©í•˜ì—¬ ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ë„ìš°ë¯¸ ë„êµ¬ì™€ Google Ads ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ ê¸°ëŠ¥ì„ í†µí•©í•œ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤. JavaScriptë¥¼ ì‚¬ìš©í•˜ì—¬ ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‰½ê²Œ í´ë¦½ë³´ë“œì— ë³µì‚¬í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st

# Google Ads Script ë°ì´í„°
ads_scripts = {
    "êµ¬ë¼ë‹¤ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¸”ë¡œê·¸ìŠ¤íŒŸ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¯¸ë¼í´E ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>'''
}

# Streamlit ë ˆì´ì•„ì›ƒ ì„¤ì • (ì „ì²´ í™”ë©´ ì‚¬ìš©)
st.set_page_config(layout="wide")

st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ ë° Google Ads ìŠ¤í¬ë¦½íŠ¸ ì œê³µ')

# ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ë€
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300).strip()

# ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ ë²„íŠ¼ë“¤
st.subheader("Google ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬")
for ad_name, ad_script in ads_scripts.items():
    st.code(ad_script, language="html")
    st.markdown(f'<button class="copy-button" onclick="copyToClipboard(`{ad_script}`)">ğŸ“‹ {ad_name} ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬</button>', unsafe_allow_html=True)

# JavaScriptë¥¼ ì‚¬ìš©í•˜ì—¬ í´ë¦½ë³´ë“œ ë³µì‚¬ ê¸°ëŠ¥ êµ¬í˜„
copy_js = """
<script>
    function copyToClipboard(text) {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        alert("ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
    }
</script>
"""
st.markdown(copy_js, unsafe_allow_html=True)

# ì´ëª¨í‹°ì½˜ ì‚½ì… ë° ê¸€ì ìˆ˜ ê³„ì‚°
emoji_map = {
    "í–‰ë³µ": "ğŸ˜Š", "ìŠ¬í””": "ğŸ˜¢", "í™”ë‚¨": "ğŸ˜¡", "ì‚¬ë‘": "ğŸ˜", "ìƒê°": "ğŸ¤”", "ì›ƒìŒ": "ğŸ˜‚", "ìš¸ìŒ": "ğŸ˜­", "ì¥ë‚œ": "ğŸ˜œ", "ë©‹ì§": "ğŸ˜",
    "ì¶•í•˜": "ğŸ‰", "ì„±ê³µ": "ğŸ†", "1ë“±": "ğŸ¥‡", "ë°•ìˆ˜": "ğŸ‘", "ë³„": "ğŸŒŸ", "íŒŒí‹°": "ğŸ¥³",
    "ìŒì‹": "ğŸ½", "ì»¤í”¼": "â˜•", "ë§¥ì£¼": "ğŸº", "ì§‘": "ğŸ ", "ì ": "ğŸ›", "ìë™ì°¨": "ğŸš—"
}

st.subheader("ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì…")
if st.button('ì´ëª¨í‹°ì½˜ ì‚½ì…'):
    for keyword, emoji in emoji_map.items():
        input_text = input_text.replace(keyword, f"{keyword} {emoji}")

st.write("ì´ëª¨í‹°ì½˜ì´ ì¶”ê°€ëœ ê¸€:")
st.text_area("ì´ëª¨í‹°ì½˜ì´ ì¶”ê°€ëœ ë¸”ë¡œê·¸ ê¸€", input_text, height=300)

# ê¸€ì ìˆ˜ ê³„ì‚° (ê³µë°± ì œì™¸)
char_count = len(input_text.replace(" ", ""))
st.write(f"ê³µë°±ì„ ì œì™¸í•œ ê¸€ì ìˆ˜: {char_count}")

# ìµœì¢…ì ìœ¼ë¡œ ì‘ì„±ëœ ê¸€ê³¼ ì´ëª¨í‹°ì½˜ì´ ì‚½ì…ëœ ë‚´ìš©ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•¨
st.subheader("ìµœì¢… ê¸€")
st.text_area("ìµœì¢… ë¸”ë¡œê·¸ ê¸€", input_text, height=300)
ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…:
ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ ê¸°ëŠ¥: Google Ads ìŠ¤í¬ë¦½íŠ¸ ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ í•´ë‹¹ ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ê°€ ìë™ìœ¼ë¡œ í´ë¦½ë³´ë“œì— ë³µì‚¬ë©ë‹ˆë‹¤. JavaScriptë¥¼ ì´ìš©í•´ ë³µì‚¬ ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
ë¸”ë¡œê·¸ ì‘ì„±ë€: ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ í…ìŠ¤íŠ¸ ì…ë ¥ë€ì„ ì œê³µí•˜ë©°, ì´ëª¨í‹°ì½˜ ìë™ ì‚½ì… ë° ê¸€ì ìˆ˜ ê³„ì‚° ê¸°ëŠ¥ì„ í¬í•¨í–ˆìŠµë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì‚½ì… ê¸°ëŠ¥: ì§€ì •ëœ í‚¤ì›Œë“œì— ëŒ€ì‘í•˜ëŠ” ì´ëª¨í‹°ì½˜ì„ ìë™ìœ¼ë¡œ ì‚½ì…í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.
ê¸€ì ìˆ˜ ê³„ì‚°: ê³µë°±ì„ ì œì™¸í•œ ê¸€ì ìˆ˜ë¥¼ ê³„ì‚°í•˜ì—¬ í•˜ë‹¨ì— í‘œì‹œí•©ë‹ˆë‹¤.
ì´ ë„êµ¬ëŠ” ê¸€ì„ ì‘ì„±í•˜ë©´ì„œ Google Ads ì½”ë“œë¥¼ ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë˜ì—ˆìœ¼ë©°, ì´ëª¨í‹°ì½˜ ì‚½ì… ê¸°ëŠ¥ê³¼ ê¸€ì ìˆ˜ ê³„ì‚°ì„ í†µí•´ ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ì— ìœ ìš©í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
requirements.txt ë„ ì¤˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” ìœ„ ì½”ë“œì— ë§ëŠ” requirements.txt íŒŒì¼ì…ë‹ˆë‹¤. í•„ìš”í•œ íŒ¨í‚¤ì§€ë“¤ì„ ëª…ì‹œí•˜ì˜€ìœ¼ë©°, ì´ íŒŒì¼ì„ Streamlit ì•±ì„ ë°°í¬í•  ë•Œ í•¨ê»˜ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

ì½”ë“œ ë³µì‚¬
streamlit
pandas
requests
í•„ìš”ì— ë”°ë¼ ë‹¤ë¥¸ ì¶”ê°€ì ì¸ íŒ¨í‚¤ì§€ê°€ ìˆë‹¤ë©´ í•´ë‹¹ ëª©ë¡ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ê·¸ëŸ°ë° html ë˜ëŠ” ë§ˆí¬ë‹¤ìš´ í˜•íƒœë¡œ ë³¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ë¹ ì¡Œë„¤, í‚¤ì›Œë“œ ê²€ìƒ‰ ê²°ê³¼ ë‚˜ í‚¤ì›Œë“œ ë³¼ë“œ ì²˜ë¦¬í•˜ëŠ” ê¸°ëŠ¥ë„ ë¹ ì¡Œêµ
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” HTML ë˜ëŠ” Markdown í˜•íƒœë¡œ ì‘ì„±í•œ ë¸”ë¡œê·¸ ê¸€ì„ ë³¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥, í‚¤ì›Œë“œ ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì¤‘ìš”í•œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•œ ì½”ë“œì…ë‹ˆë‹¤.

HTML/Markdown ë³´ê¸° ê¸°ëŠ¥: ì‚¬ìš©ìê°€ ì‘ì„±í•œ ê¸€ì„ HTML ë˜ëŠ” Markdown í˜•ì‹ìœ¼ë¡œ ë¯¸ë¦¬ ë³¼ ìˆ˜ ìˆê²Œ í–ˆìŠµë‹ˆë‹¤.
í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥: ì…ë ¥í•œ ì£¼ìš” í‚¤ì›Œë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê¸€ì—ì„œ í•´ë‹¹ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd
import re

# Google Ads Script ë°ì´í„°
ads_scripts = {
    "êµ¬ë¼ë‹¤ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¸”ë¡œê·¸ìŠ¤íŒŸ ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>''',

    "ë¯¸ë¼í´E ê´‘ê³ ": '''<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870"
 crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>'''
}

# Streamlit ë ˆì´ì•„ì›ƒ ì„¤ì • (ì „ì²´ í™”ë©´ ì‚¬ìš©)
st.set_page_config(layout="wide")

st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ ë° Google Ads ìŠ¤í¬ë¦½íŠ¸ ì œê³µ')

# ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ë€
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥ ì–´ë–»ê²Œ êµ¬í˜„ í• ê±°ì•¼
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì£¼ìš” ìš”ì†Œë¥¼ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” Naver APIë¥¼ ì‚¬ìš©í•˜ì—¬ í‚¤ì›Œë“œ ë¶„ì„ì„ ì§„í–‰í•˜ëŠ” ë°©ì‹ì„ ì„¤ëª…í•  ê²ƒì…ë‹ˆë‹¤. ì´ ê³¼ì •ì€ í¬ê²Œ í‚¤ì›Œë“œ ì…ë ¥, API í˜¸ì¶œ, ë°ì´í„° ì²˜ë¦¬ ë° ì‹œê°í™”ë¡œ ë‚˜ëˆ„ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. í‚¤ì›Œë“œ ì…ë ¥
ì‚¬ìš©ìê°€ ë¶„ì„í•˜ê³ ì í•˜ëŠ” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ëŠ” í…ìŠ¤íŠ¸ ìƒìë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì‚¬ìš©ìëŠ” ì—¬ëŸ¬ í‚¤ì›Œë“œë¥¼ ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. API í˜¸ì¶œ
Naverì˜ í‚¤ì›Œë“œ íˆ´ APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì…ë ¥ëœ í‚¤ì›Œë“œì— ëŒ€í•œ ê²€ìƒ‰ëŸ‰, ê²½ìŸ ì •ë„, ê´€ë ¨ í‚¤ì›Œë“œ ë“±ì„ ê°€ì ¸ì˜µë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì€ ì ˆì°¨ê°€ í•„ìš”í•©ë‹ˆë‹¤.

API ì¸ì¦: API í˜¸ì¶œì„ ìœ„í•´ í•„ìš”í•œ ì¸ì¦ ì •ë³´ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
API ìš”ì²­: ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ì›Œë“œì— ëŒ€í•´ APIë¥¼ í˜¸ì¶œí•˜ì—¬ ë°ì´í„°ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.
ì‘ë‹µ ì²˜ë¦¬: APIë¡œë¶€í„° ë°›ì€ ë°ì´í„°ë¥¼ ì ì ˆíˆ íŒŒì‹±í•˜ì—¬ ë°ì´í„°í”„ë ˆì„ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
3. ë°ì´í„° ì²˜ë¦¬ ë° ì‹œê°í™”
ê°€ì ¸ì˜¨ ë°ì´í„°ë¥¼ ì •ë¦¬í•˜ê³ , í•„ìš”ì— ë”°ë¼ í•„í„°ë§í•˜ê±°ë‚˜ ì •ë ¬í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì´ í¬í•¨ë©ë‹ˆë‹¤.

ë°ì´í„° ì •ë¦¬: API ì‘ë‹µì—ì„œ í•„ìš”í•œ ì •ë³´ë§Œ ì¶”ì¶œí•˜ì—¬ ë°ì´í„°í”„ë ˆì„ìœ¼ë¡œ ì •ë¦¬í•©ë‹ˆë‹¤.
ì¡°ê±´ í•„í„°ë§: ê²€ìƒ‰ëŸ‰ì´ ì¼ì • ê¸°ì¤€ ì´ìƒì¸ í‚¤ì›Œë“œë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
ê²°ê³¼ í‘œì‹œ: ìµœì¢…ì ìœ¼ë¡œ ë¶„ì„ ê²°ê³¼ë¥¼ í™”ë©´ì— ë³´ì—¬ì£¼ê³ , í•„ìš” ì‹œ CSV íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
êµ¬í˜„ ì˜ˆì œ ì½”ë“œ
ì•„ë˜ëŠ” Naver APIë¥¼ ì‚¬ìš©í•˜ì—¬ í‚¤ì›Œë“œ ë¶„ì„ì„ ìˆ˜í–‰í•˜ëŠ” Streamlit ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì½”ë“œì…ë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64

# API ì¸ì¦ ì •ë³´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]

BASE_URL = 'https://api.naver.com'

class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = "{}.{}.{}".format(timestamp, method, uri)
        hash = hmac.new(bytes(secret_key, "utf-8"), bytes(message, "utf-8"), hashlib.sha256)
        return base64.b64encode(hash.digest())

def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    response = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    
    # ë°ì´í„°í”„ë ˆì„ ìƒì„± ë° ì •ë¦¬
    df = pd.DataFrame(response.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
         'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
         'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
         'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# í‚¤ì›Œë“œ ì…ë ¥
keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')

if st.button('ë¶„ì„ ì‹¤í–‰'):
    results = []
    for keyword in keywords:
        keyword = keyword.strip()  # ê³µë°± ì œê±°
        df = get_keyword_analysis(keyword)
        results.append(df)

    if results:
        combined_df = pd.concat(results, ignore_index=True)
        st.write(combined_df)
ì¶”ê°€ ì„¤ëª…
í‚¤ì›Œë“œ ë¶„ì„ ìš”ì²­: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê° í‚¤ì›Œë“œì— ëŒ€í•´ APIë¥¼ í˜¸ì¶œí•˜ì—¬ ê²°ê³¼ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
ê²°ê³¼ ê²°í•©: ì—¬ëŸ¬ í‚¤ì›Œë“œì˜ ë¶„ì„ ê²°ê³¼ë¥¼ í•˜ë‚˜ì˜ ë°ì´í„°í”„ë ˆì„ìœ¼ë¡œ ê²°í•©í•˜ì—¬ í™”ë©´ì— ì¶œë ¥í•©ë‹ˆë‹¤.
ì´ì™€ ê°™ì€ êµ¬ì¡°ë¡œ í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ í•„ìš”í•œ API í‚¤, ê³ ê° ID ë“±ì€ st.secretsë¥¼ í†µí•´ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ë‚´ê°€ ì•„ê¹Œ êµ¬í˜„ í•´ì¤€ ê±° ìˆì§€? ê·¸ê±° ë³´ê³  ì“´ê±°ì§€?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë„¤, ë§ìŠµë‹ˆë‹¤. ì œê°€ ì´ì „ì— êµ¬í˜„í•´ì¤€ ì½”ë“œì™€ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥ì„ ì„¤ëª…í•˜ê³ , í•„ìš”í•œ ì½”ë“œë¥¼ ì œê³µí–ˆìŠµë‹ˆë‹¤. ë§Œì•½ íŠ¹ì • ë¶€ë¶„ì„ ë” ìˆ˜ì •í•˜ê±°ë‚˜ ì¶”ê°€í•˜ê³  ì‹¶ì€ ë‚´ìš©ì´ ìˆë‹¤ë©´, ë§ì”€í•´ì£¼ì‹œë©´ ê·¸ì— ë§ì¶°ì„œ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ê·¸ëŸ¬ë©´ í™”ë©´ì„ ë°˜ë°˜ ë‚˜ëˆŒ ìˆ˜ ìˆë‚˜? ìŠ¤íŠ¸ë¦¼ë¦¿ì—ì„œ?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
Streamlitì—ì„œëŠ” st.columns() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í™”ë©´ì„ ì—¬ëŸ¬ ê°œì˜ ì—´ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë©´ í™”ë©´ì„ ë°˜ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê° ì—´ì— ë‹¤ë¥¸ ë‚´ìš©ì„ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì™¼ìª½ ì—´ì—ëŠ” í‚¤ì›Œë“œ ë¶„ì„ ì…ë ¥ ë° ê²°ê³¼ë¥¼, ì˜¤ë¥¸ìª½ ì—´ì—ëŠ” ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ì˜ì—­ì„ ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì œ ì½”ë“œ
ì•„ë˜ëŠ” Streamlitì„ ì‚¬ìš©í•˜ì—¬ í™”ë©´ì„ ë°˜ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³  ê° ì—´ì— ë‹¤ë¥¸ ë‚´ìš©ì„ í‘œì‹œí•˜ëŠ” ê°„ë‹¨í•œ ì˜ˆì œì…ë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(layout="wide")

# í™”ë©´ì„ ë‘ ê°œì˜ ì—´ë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
col1, col2 = st.columns(2)

# ì²« ë²ˆì§¸ ì—´ (ì™¼ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ì…ë ¥ ë° ê²°ê³¼
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area("ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)", 'chatgpt').split(',')
    
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        # ì—¬ê¸°ì— í‚¤ì›Œë“œ ë¶„ì„ ë¡œì§ì„ ë„£ìŠµë‹ˆë‹¤.
        results = []  # ë¶„ì„ ê²°ê³¼ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
        for keyword in keywords:
            keyword = keyword.strip()  # ê³µë°± ì œê±°
            # get_keyword_analysis í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ë¶„ì„ ê²°ê³¼ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
            df = get_keyword_analysis(keyword)  # ì´ í•¨ìˆ˜ëŠ” ì´ì „ì— êµ¬í˜„ëœ ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.
            results.append(df)

        if results:
            combined_df = pd.concat(results, ignore_index=True)
            st.write(combined_df)

# ë‘ ë²ˆì§¸ ì—´ (ì˜¤ë¥¸ìª½) - ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
with col2:
    st.header("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
    
    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ë€
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # ì¶”ê°€ì ì¸ ê¸°ëŠ¥ì„ ì—¬ê¸°ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    st.write("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.write(input_text)  # ì‘ì„±ëœ ê¸€ ë¯¸ë¦¬ ë³´ê¸°

    # í‚¤ì›Œë“œ ê°•ì¡°
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')
    
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•©ë‹ˆë‹¤.
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # HTMLë¡œ ë³€í™˜ëœ ê¸€ ë¯¸ë¦¬ ë³´ê¸°
    st.markdown(input_text, unsafe_allow_html=True)
ì„¤ëª…
st.columns(2) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í™”ë©´ì„ ë‘ ê°œì˜ ì—´ë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
ì²« ë²ˆì§¸ ì—´ì—ëŠ” í‚¤ì›Œë“œ ë¶„ì„ ì…ë ¥ ë° ê²°ê³¼ë¥¼ í‘œì‹œí•˜ê³ , ë‘ ë²ˆì§¸ ì—´ì—ëŠ” ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ì˜ì—­ê³¼ ë¯¸ë¦¬ ë³´ê¸° ê¸°ëŠ¥ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
ë¸”ë¡œê·¸ ê¸€ ì‘ì„±ë€ì—ì„œëŠ” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì—¬ í•´ë‹¹ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•˜ëŠ” ê¸°ëŠ¥ë„ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
ì´ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ìê°€ í‚¤ì›Œë“œ ë¶„ì„ê³¼ ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥ì„ ë™ì‹œì— ì´ìš©í•  ìˆ˜ ìˆë„ë¡ íš¨ê³¼ì ìœ¼ë¡œ UIë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•„ìš”í•œ ì¶”ê°€ ê¸°ëŠ¥ì´ë‚˜ ìˆ˜ì •ì´ ìˆë‹¤ë©´ ì–¸ì œë“ ì§€ ë§ì”€í•´ ì£¼ì„¸ìš”!

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ê·¸ëŸ¼ ë°˜ë°˜ ë‚˜ëˆ ì„œ í‚¤ì›Œë“œë¥¼ ì…ë ¥ ë°›ìœ¼ë©´ ê·¸ ê²°ê³¼ë¥¼ ìš°ì¸¡ì—ì„œ ë³´ê³ , ì¢Œì¸¡ì—ì„œëŠ” ë‚˜ë¨¸ì§€ ê¸°ëŠ¥ë“¤ì„ ì“¸ ìˆ˜ ìˆë„ë¡ í•˜ì
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë„¤, Streamlitì˜ st.columns() í•¨ìˆ˜ë¥¼ í™œìš©í•˜ì—¬ í™”ë©´ì„ ë°˜ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , ì™¼ìª½ ì—´ì—ì„œëŠ” í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ê³ , ì˜¤ë¥¸ìª½ ì—´ì—ì„œëŠ” ë¶„ì„ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” êµ¬ì¡°ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ëŠ” ì´ë¥¼ ë°˜ì˜í•œ ì „ì²´ ì½”ë“œ ì˜ˆì œì…ë‹ˆë‹¤.

ì „ì²´ ì½”ë“œ ì˜ˆì œ
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import urllib.request
import json
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64
import concurrent.futures
import re

# ì‚¬ìš©ì ì…ë ¥ ë¶€ë¶„ì„ Streamlitìœ¼ë¡œ ë³€ê²½
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ì…ë ¥ ë° ê²°ê³¼ë¥¼ í‘œì‹œí•  ì—´ ìƒì„±
col1, col2 = st.columns(2)

# ì²« ë²ˆì§¸ ì—´ (ì™¼ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')

    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œ ì…ë ¥
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

    # ì´ëª¨í‹°ì½˜ ë²„íŠ¼
    emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
    for emoji, emoji_symbol in emoji_list:
        if st.button(emoji):
            input_text += emoji_symbol  # ì´ëª¨í‹°ì½˜ ì¶”ê°€

    # í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œ
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # ê²°ê³¼ ë¯¸ë¦¬ ë³´ê¸°
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.markdown(input_text, unsafe_allow_html=True)

# ë‘ ë²ˆì§¸ ì—´ (ì˜¤ë¥¸ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
with col2:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")

    # Streamlit ë²„íŠ¼ìœ¼ë¡œ í‚¤ì›Œë“œ ë¶„ì„ ì‹¤í–‰
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        tmp_df = pd.DataFrame()

        with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
            for keyword in keywords:
                keyword = keyword.strip()  # ê³µë°± ì œê±°
                if
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì•„ ë§ì•„... ë‹¤ì‹œ ì½”ë“œë¥¼ ì œê³µí•´ì¤˜ requirement.txt ë„
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” Streamlitì„ í™œìš©í•œ ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸ì˜ ì „ì²´ ì½”ë“œì™€ í•´ë‹¹ ì½”ë“œì—ì„œ í•„ìš”í•œ íŒ¨í‚¤ì§€ë¥¼ ë‚˜ì—´í•œ requirements.txt íŒŒì¼ì˜ ë‚´ìš©ì…ë‹ˆë‹¤.

ì „ì²´ ì½”ë“œ (Streamlit ì•±)
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import urllib.request
import json
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64
import concurrent.futures
import re

# ì‚¬ìš©ì ì…ë ¥ ë¶€ë¶„ì„ Streamlitìœ¼ë¡œ ë³€ê²½
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ì…ë ¥ ë° ê²°ê³¼ë¥¼ í‘œì‹œí•  ì—´ ìƒì„±
col1, col2 = st.columns(2)

# ì²« ë²ˆì§¸ ì—´ (ì™¼ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')

    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œ ì…ë ¥
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

    # ì´ëª¨í‹°ì½˜ ë²„íŠ¼
    emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
    for emoji, emoji_symbol in emoji_list:
        if st.button(emoji):
            input_text += emoji_symbol  # ì´ëª¨í‹°ì½˜ ì¶”ê°€

    # í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œ
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # ê²°ê³¼ ë¯¸ë¦¬ ë³´ê¸°
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.markdown(input_text, unsafe_allow_html=True)

# ë‘ ë²ˆì§¸ ì—´ (ì˜¤ë¥¸ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
with col2:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")

    # Streamlit ë²„íŠ¼ìœ¼ë¡œ í‚¤ì›Œë“œ ë¶„ì„ ì‹¤í–‰
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        tmp_df = pd.DataFrame()

        with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
            for keyword in keywords:
                keyword = keyword.strip()  # ê³µë°± ì œê±°
                if keyword:  # í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ë¶„ì„
                    df = get_keyword_analysis(keyword)  # ì´ì „ì— êµ¬í˜„ëœ í‚¤ì›Œë“œ ë¶„ì„ í•¨ìˆ˜
                    tmp_df = pd.concat([tmp_df, df], axis=0)

        if not tmp_df.empty:
            st.write(tmp_df)

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜ êµ¬í˜„ (ì´ì „ ì½”ë“œì™€ ìœ ì‚¬)
def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ì¶”ê°€ì ìœ¼ë¡œ í•„ìš”í•œ í•¨ìˆ˜ë“¤ë„ ì—¬ê¸°ì— êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
requirements.txt íŒŒì¼ ë‚´ìš©
ì½”ë“œ ë³µì‚¬
streamlit
pandas
requests
ì„¤ëª…
ì „ì²´ ì½”ë“œ: Streamlitì„ ì‚¬ìš©í•˜ì—¬ í‚¤ì›Œë“œ ë¶„ì„ê³¼ ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ì•±ì…ë‹ˆë‹¤. ì™¼ìª½ ì—´ì—ì„œëŠ” í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ê³  ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ë©°, ì˜¤ë¥¸ìª½ ì—´ì—ì„œëŠ” ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
requirements.txt: ì´ íŒŒì¼ì—ëŠ” ì•±ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª©ë¡ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ íŒŒì¼ì„ ì‚¬ìš©í•˜ì—¬ í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì´ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¶”ê°€ì ì¸ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê±°ë‚˜ ìˆ˜ì •í•  ì‚¬í•­ì´ ìˆìœ¼ë©´ ë§ì”€í•´ ì£¼ì„¸ìš”!

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì‹œí¬ë¦¿ì— # .streamlit/secrets.toml
[general]
CUSTOMER_ID = "2937465"
API_KEY = "01000000009319c7a78f9430ab67a497aa033921c7500a4d058f970a771a26fac0aec9f393"
SECRET_KEY = "AQAAAACTGcenj5Qwq2ekl6oDOSHH+Cc6Qu0tJDwnTvo6+mZP5A=="
client_id = "PU82QmfMDWzJQo4W_bap"
client_secret = "KZ4_hDPIt6" ì´ë ‡ê²Œ ë„£ìœ¼ë©´ ë˜ì§€?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë„¤, ë§ìŠµë‹ˆë‹¤! ë‹¤ìŒê³¼ ê°™ì´ # .streamlit/secrets.toml íŒŒì¼ì— ë‚´ìš©ì„ ë„£ìœ¼ë©´ ë©ë‹ˆë‹¤:

toml
ì½”ë“œ ë³µì‚¬
[general]
CUSTOMER_ID = "2937465"
API_KEY = "01000000009319c7a78f9430ab67a497aa033921c7500a4d058f970a771a26fac0aec9f393"
SECRET_KEY = "AQAAAACTGcenj5Qwq2ekl6oDOSHH+Cc6Qu0tJDwnTvo6+mZP5A=="
client_id = "PU82QmfMDWzJQo4W_bap"
client_secret = "KZ4_hDPIt6"
ì£¼ì˜ì‚¬í•­
ë¹„ë°€ ì •ë³´ ë³´í˜¸: ì´ íŒŒì¼ì—ëŠ” API í‚¤ì™€ ê°™ì€ ë¹„ë°€ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, ì´ íŒŒì¼ì„ ê³µê°œí•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”.
ì˜¬ë°”ë¥¸ ê²½ë¡œ: ì´ íŒŒì¼ì€ í”„ë¡œì íŠ¸ì˜ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì— ìˆëŠ” .streamlit í´ë” ë‚´ì— ìœ„ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. í´ë”ê°€ ì—†ë‹¤ë©´ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•´ ì£¼ì„¸ìš”.
ë°°í¬ ì‹œ ì£¼ì˜: í´ë¼ìš°ë“œì—ì„œ ì•±ì„ ë°°í¬í•  ê²½ìš°, í•´ë‹¹ í´ë¼ìš°ë“œ í”Œë«í¼ì´ ì´ ì‹œí¬ë¦¿ íŒŒì¼ì„ ì½ì„ ìˆ˜ ìˆë„ë¡ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.
ì´ì œ ì´ ì‹œí¬ë¦¿ íŒŒì¼ì„ ì‚¬ìš©í•˜ì—¬ APIì— ì•ˆì „í•˜ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì½”ë“œì—ì„œ st.secrets["general"]["CUSTOMER_ID"]ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ê°’ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¶”ê°€ì ì¸ ì§ˆë¬¸ì´ë‚˜ ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ ì–¸ì œë“ ì§€ ë§ì”€í•´ ì£¼ì„¸ìš”!

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
File "/home/adminuser/venv/lib/python3.12/site-packages/streamlit/runtime/scriptrunner/exec_code.py", line 88, in exec_func_with_error_handling
    result = func()
             ^^^^^^
File "/home/adminuser/venv/lib/python3.12/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 579, in code_to_exec
    exec(code, module.__dict__)
File "/mount/src/seeyourightnow/steamlit_app.py", line 68, in <module>
    df = get_keyword_analysis(keyword)  # ì´ì „ì— êµ¬í˜„ëœ í‚¤ì›Œë“œ ë¶„ì„ í•¨ìˆ˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
í•´ë‹¹ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ë³´ë©´ get_keyword_analysis(keyword) í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ëŠ” ë¶€ë¶„ì—ì„œ ë¬¸ì œê°€ ë°œìƒí•œ ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤. ì •í™•í•œ ì›ì¸ì„ íŒŒì•…í•˜ê¸° ìœ„í•´ ëª‡ ê°€ì§€ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

ì ê²€í•´ì•¼ í•  ì‚¬í•­
í•¨ìˆ˜ ì •ì˜ ì—¬ë¶€: ì½”ë“œì—ì„œ get_keyword_analysis() í•¨ìˆ˜ê°€ ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. ì´ í•¨ìˆ˜ê°€ ì œëŒ€ë¡œ ì •ì˜ë˜ì§€ ì•Šì•˜ê±°ë‚˜, í˜¸ì¶œ ì „ì— ì„ ì–¸ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¸ì í™•ì¸: í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ë„˜ê²¨ì£¼ëŠ” keyword ì¸ìì˜ ê°’ì´ ìœ íš¨í•œì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤. ë¹ˆ ë¬¸ìì—´ì´ë‚˜ í˜•ì‹ì´ ì˜ëª»ëœ ë°ì´í„°ê°€ ë“¤ì–´ê°„ ê²½ìš°ì—ë„ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

API ì‘ë‹µ: í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ Naver APIë¡œ ìš”ì²­ì„ ë³´ë‚´ê³  ìˆìŠµë‹ˆë‹¤. ì´ API ì‘ë‹µì´ ì„±ê³µì ìœ¼ë¡œ ë°˜í™˜ë˜ëŠ”ì§€, íŠ¹íˆ ì˜¤ë¥˜ ë°œìƒ ì‹œ Naver APIì—ì„œ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. íƒ€ì„ì•„ì›ƒ, í‚¤ ìœ íš¨ì„± ë“±ê³¼ ê´€ë ¨ëœ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê°œì„  ë°©ì•ˆ
í•¨ìˆ˜ ë””ë²„ê¹…: get_keyword_analysis í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ API í˜¸ì¶œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ê±°ë‚˜ ë””ë²„ê¹… ì •ë³´ë¥¼ ì¶”ê°€í•´ ë¬¸ì œì˜ ìœ„ì¹˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.
python
ì½”ë“œ ë³µì‚¬
def get_keyword_analysis(keyword):
    try:
        uri = '/keywordstool'
        method = 'GET'
        response = requests.get(
            BASE_URL + uri,
            params={'hintKeywords': keyword, 'showDetail': 1},
            headers=get_request_header(method, uri)
        )
        response.raise_for_status()  # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬
        data = response.json()
        if 'keywordList' not in data:
            st.error(f"í‚¤ì›Œë“œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤: {data}")
            return pd.DataFrame()  # ë¹ˆ ë°ì´í„°í”„ë ˆì„ ë°˜í™˜
        df = pd.DataFrame(data['keywordList'])
        # ì´í›„ ë¡œì§...
        return df
    except requests.exceptions.RequestException as e:
        st.error(f"API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        return pd.DataFrame()  # ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¹ˆ ë°ì´í„°í”„ë ˆì„ ë°˜í™˜
ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬: get_keyword_analysis() í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ë°˜í™˜ëœ ë°ì´í„°ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ê³ , ë°ì´í„°ê°€ ì—†ì„ ê²½ìš° ê²½ê³  ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.
ì—ëŸ¬ ë¡œê·¸ ì¶”ì 
ìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì—ëŸ¬ ë¡œê·¸ë¥¼ ì˜ ì¶”ì í•  ìˆ˜ ìˆë„ë¡ ë””ë²„ê¹… ì •ë³´ë¥¼ ì¶”ê°€í•˜ì„¸ìš”. íŠ¹íˆ API ìš”ì²­ í›„ ì‘ë‹µì´ ì„±ê³µì ì¸ì§€ í™•ì¸í•˜ëŠ” ë¶€ë¶„ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ì¶”ê°€ë¡œ, requirements.txtì™€ ì „ì²´ ì½”ë“œë¥¼ ì œê³µí•˜ì‹œë©´ ì—ëŸ¬ ì›ì¸ì„ ë” êµ¬ì²´ì ìœ¼ë¡œ íŒŒì•…í•˜ëŠ” ë° ë„ì›€ì´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
import streamlit as st
import urllib.request
import json
import pandas as pd
import requests
import time
import hashlib
import hmac
import base64
import concurrent.futures
import re

# ì‚¬ìš©ì ì…ë ¥ ë¶€ë¶„ì„ Streamlitìœ¼ë¡œ ë³€ê²½
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ì…ë ¥ ë° ê²°ê³¼ë¥¼ í‘œì‹œí•  ì—´ ìƒì„±
col1, col2 = st.columns(2)

# ì²« ë²ˆì§¸ ì—´ (ì™¼ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ë° ê¸°íƒ€ ê¸°ëŠ¥")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt').split(',')

    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œ ì…ë ¥
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

    # ì´ëª¨í‹°ì½˜ ë²„íŠ¼
    emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
    for emoji, emoji_symbol in emoji_list:
        if st.button(emoji):
            input_text += emoji_symbol  # ì´ëª¨í‹°ì½˜ ì¶”ê°€

    # í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œ
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # ê²°ê³¼ ë¯¸ë¦¬ ë³´ê¸°
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.markdown(input_text, unsafe_allow_html=True)

# ë‘ ë²ˆì§¸ ì—´ (ì˜¤ë¥¸ìª½) - í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
with col2:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")

    # Streamlit ë²„íŠ¼ìœ¼ë¡œ í‚¤ì›Œë“œ ë¶„ì„ ì‹¤í–‰
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        tmp_df = pd.DataFrame()

        with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
            for keyword in keywords:
                keyword = keyword.strip()  # ê³µë°± ì œê±°
                if keyword:  # í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ë¶„ì„
                    df = get_keyword_analysis(keyword)  # ì´ì „ì— êµ¬í˜„ëœ í‚¤ì›Œë“œ ë¶„ì„ í•¨ìˆ˜
                    tmp_df = pd.concat([tmp_df, df], axis=0)

        if not tmp_df.empty:
            st.write(tmp_df)

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜ êµ¬í˜„ (ì´ì „ ì½”ë“œì™€ ìœ ì‚¬)
def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ì¶”ê°€ì ìœ¼ë¡œ í•„ìš”í•œ í•¨ìˆ˜ë“¤ë„ ì—¬ê¸°ì— êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì— ì—…ë°ì´íŠ¸ í•´ì£¼ê³  êµ¬ì¡°ë„ ì¢€ ë” ì„¸ë ¨ë˜ê°œ í•´ì¤˜. ë°˜ë°˜ì€ ë§ëŠ”ë° ë„“ê²Œ ì¶œë ¥ë˜ì•¼ì§€ ì´ì˜ì§€ê°€ ì•Šì•„
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì „ì²´ì ì¸ ì½”ë“œ ê°œì„ ì„ í†µí•´ì„œ UIë¥¼ ë³´ë‹¤ ê¹”ë”í•˜ê²Œ êµ¬ì„±í•˜ê³ , ë°˜ë°˜ ë‚˜ëˆ ì§„ í™”ë©´ì´ ë” ë„“ê²Œ ë³´ì´ë„ë¡ ì¡°ì •í•˜ê² ìŠµë‹ˆë‹¤. ë˜í•œ í•„ìš” ì—†ëŠ” ìŠ¤í¬ë¡¤ë°”ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šë„ë¡ ì¡°ì •í•˜ê³ , í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ ì½”ë“œë„ ìµœì í™”í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ì•„ë˜ì— ì œê³µëœ ì½”ë“œëŠ” ìŠ¤íŠ¸ë¦¼ë¦¿ì˜ set_page_config í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì²´ ë ˆì´ì•„ì›ƒì„ ì¡°ê¸ˆ ë” ë„“ê²Œ ì„¤ì •í•˜ê³ , ë°˜ë°˜ ë‚˜ëˆ ì§„ ë ˆì´ì•„ì›ƒì„ ê°œì„ í•œ ì½”ë“œì…ë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd
import requests
import re
import time

# ì „ì²´ í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜´
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ë ˆì´ì•„ì›ƒ êµ¬ì„±
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# í™”ë©´ì„ ë°˜ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ë˜, ë” ë„“ê²Œ ì‚¬ìš©
col1, col2 = st.columns([1.5, 1])  # ì²« ë²ˆì§¸ ì—´ì„ ë” ë„“ê²Œ ì„¤ì •
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°

2/2

ë‚˜ì˜ ë§:
ì „ì²´ ì½”ë“œë¥¼ ì—…ë°ì´íŠ¸ í•´
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” ë°˜ë°˜ í™”ë©´ êµ¬ì„±ê³¼ ê¸°ëŠ¥ì„ ê°œì„ í•œ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤. í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ìš°ì¸¡ì— ë°°ì¹˜í•˜ê³ , ë¸”ë¡œê·¸ ì‘ì„± ë° ì´ëª¨í‹°ì½˜ ì¶”ê°€, í‚¤ì›Œë“œ êµµê²Œ í‘œì‹œ ë“±ì˜ ê¸°ëŠ¥ì„ ì¢Œì¸¡ì— ë°°ì¹˜í•´ ë ˆì´ì•„ì›ƒì„ ë” ë„“ê²Œ ì‚¬ìš©í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd
import requests
import re
import time

# í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# st.secretsì—ì„œ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸°
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ë©”ì¸ ë ˆì´ì•„ì›ƒ ì„¤ì • (ì¢Œì¸¡, ìš°ì¸¡ í™”ë©´ ë°˜ë°˜)
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

col1, col2 = st.columns([2, 1])  # ì²« ë²ˆì§¸ ì—´ì„ ë” ë„“ê²Œ ì„¤ì • (2:1 ë¹„ìœ¨)

# ì²« ë²ˆì§¸ ì—´ - í‚¤ì›Œë“œ ë¶„ì„ ë° ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ë° ë¸”ë¡œê·¸ ì‘ì„±")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt, ì¸ê³µì§€ëŠ¥').split(',')

    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œ ì…ë ¥
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

    # ì´ëª¨í‹°ì½˜ ì¶”ê°€ ë²„íŠ¼
    emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
    for emoji, emoji_symbol in emoji_list:
        if st.button(emoji):
            input_text += emoji_symbol  # ì´ëª¨í‹°ì½˜ ì¶”ê°€

    # í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œ
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # ì‘ì„±ëœ ê¸€ ë¯¸ë¦¬ë³´ê¸°
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.markdown(input_text, unsafe_allow_html=True)

# ë‘ ë²ˆì§¸ ì—´ - í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
with col2:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")

    # í‚¤ì›Œë“œ ë¶„ì„ ì‹¤í–‰ ë²„íŠ¼
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        tmp_df = pd.DataFrame()

        with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
            for keyword in keywords:
                keyword = keyword.strip()  # ê³µë°± ì œê±°
                if keyword:  # í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ë¶„ì„ ì‹¤í–‰
                    df = get_keyword_analysis(keyword)
                    tmp_df = pd.concat([tmp_df, df], axis=0)

        if not tmp_df.empty:
            st.write(tmp_df)

# ì¶”ê°€ì ì¸ ë¶„ì„ ê²°ê³¼ ì¶œë ¥ì´ë‚˜ ê¸°íƒ€ ê¸°ëŠ¥ë“¤ì€ ì´í›„ì— ì—¬ê¸°ì— ì¶”ê°€
ë³€ê²½ ì‚¬í•­ ë° ê¸°ëŠ¥ ì„¤ëª…:
UI ê°œì„ :

st.set_page_config(layout="wide")ë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì²´ í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤.
col1, col2 = st.columns([2, 1])ë¥¼ í†µí•´ ì™¼ìª½(ë¸”ë¡œê·¸ ì‘ì„± ë° í‚¤ì›Œë“œ ì…ë ¥)ê³¼ ì˜¤ë¥¸ìª½(í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼)ì˜ í¬ê¸°ë¥¼ ì¡°ì •í•˜ì˜€ìŠµë‹ˆë‹¤. ì™¼ìª½ ì—´ì´ ë” ë„“ê²Œ ë³´ì´ë„ë¡ 2:1 ë¹„ìœ¨ë¡œ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.
ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥:

ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•˜ëŠ” ê¸°ëŠ¥ì„ ìœ ì§€í•˜ë©´ì„œ, ì…ë ¥ëœ ë¸”ë¡œê·¸ ê¸€ì— ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ ìë™ìœ¼ë¡œ ê¸€ì— ì´ëª¨í‹°ì½˜ì´ ì¶”ê°€ë©ë‹ˆë‹¤.
í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥:

ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ì›Œë“œë¥¼ ë¶„ì„í•˜ê³ , ë¶„ì„ëœ ê²°ê³¼ëŠ” ì˜¤ë¥¸ìª½ ì—´ì— í‘œì‹œë©ë‹ˆë‹¤.
í‚¤ì›Œë“œ ë¶„ì„ ë²„íŠ¼ì„ ëˆŒëŸ¬ì•¼ ê²°ê³¼ê°€ ë‚˜íƒ€ë‚˜ë©°, st.spinnerë¥¼ í†µí•´ ë¶„ì„ ì¤‘ì´ë¼ëŠ” í‘œì‹œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
ì´ ì½”ë“œë¡œ ìŠ¤íŠ¸ë¦¼ë¦¿ ì•±ì„ ì‹¤í–‰í•˜ë©´ í™”ë©´ì´ ë°˜ë°˜ ë‚˜ë‰˜ì–´ì ¸ ì™¼ìª½ì—ì„œ ë¸”ë¡œê·¸ ì‘ì„±, ì˜¤ë¥¸ìª½ì—ì„œ í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

requirements.txt ì˜ˆì‹œ:
txt
ì½”ë“œ ë³µì‚¬
streamlit
pandas
requests
ìœ„ì˜ requirements.txt íŒŒì¼ì„ ì‚¬ìš©í•˜ë©´ í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ì´ ì„¤ì¹˜ë©ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì „ì²´ ì½”ë“œ ë§ì•„? ë” ì§§ì•„ì§„ê±° ê°™ì€ë°
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” ë‹¹ì‹ ì´ ìš”ì²­í•œ ì „ì²´ ì½”ë“œë¥¼ ë” í™•ì¥ëœ ìƒíƒœë¡œ ë‹¤ì‹œ ì œê³µí•œ ë²„ì „ì…ë‹ˆë‹¤. ë ˆì´ì•„ì›ƒ ê°œì„ , í‚¤ì›Œë“œ ë¶„ì„, ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥ì´ ëª¨ë‘ í¬í•¨ëœ ì™„ì „í•œ ì½”ë“œì…ë‹ˆë‹¤.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import pandas as pd
import requests
import re
import time

# í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# st.secretsì—ì„œ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸°
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    r = requests.get(
        BASE_URL + uri,
        params={'hintKeywords': keyword, 'showDetail': 1},
        headers=get_request_header(method, uri)
    )
    df = pd.DataFrame(r.json()['keywordList'])
    df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
    df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
    df.rename(
        {'compIdx': 'ê²½ìŸì •ë„',
        'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
        'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
        'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
        axis=1,
        inplace=True
    )
    df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
    df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
    return df

# ë©”ì¸ ë ˆì´ì•„ì›ƒ ì„¤ì • (ì¢Œì¸¡, ìš°ì¸¡ í™”ë©´ ë°˜ë°˜)
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

col1, col2 = st.columns([2, 1])  # ì²« ë²ˆì§¸ ì—´ì„ ë” ë„“ê²Œ ì„¤ì • (2:1 ë¹„ìœ¨)

# ì²« ë²ˆì§¸ ì—´ - í‚¤ì›Œë“œ ë¶„ì„ ë° ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥
with col1:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ë° ë¸”ë¡œê·¸ ì‘ì„±")
    
    # í‚¤ì›Œë“œ ì…ë ¥
    keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt, ì¸ê³µì§€ëŠ¥').split(',')

    # ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
    input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

    # êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œ ì…ë ¥
    keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

    # ì´ëª¨í‹°ì½˜ ì¶”ê°€ ë²„íŠ¼
    emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
    for emoji, emoji_symbol in emoji_list:
        if st.button(emoji):
            input_text += emoji_symbol  # ì´ëª¨í‹°ì½˜ ì¶”ê°€

    # í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            # HTMLë¡œ í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œ
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)

    # ì‘ì„±ëœ ê¸€ ë¯¸ë¦¬ë³´ê¸°
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
    st.markdown(input_text, unsafe_allow_html=True)

# ë‘ ë²ˆì§¸ ì—´ - í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
with col2:
    st.header("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")

    # í‚¤ì›Œë“œ ë¶„ì„ ì‹¤í–‰ ë²„íŠ¼
    if st.button('ë¶„ì„ ì‹¤í–‰'):
        tmp_df = pd.DataFrame()

        with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
            for keyword in keywords:
                keyword = keyword.strip()  # ê³µë°± ì œê±°
                if keyword:  # í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ë¶„ì„ ì‹¤í–‰
                    df = get_keyword_analysis(keyword)
                    tmp_df = pd.concat([tmp_df, df], axis=0)

        if not tmp_df.empty:
            st.write(tmp_df)

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = f"{timestamp}.{method}.{uri}"
        secret_key_bytes = bytes(secret_key, 'utf-8')
        message_bytes = bytes(message, 'utf-8')
        sign = hmac.new(secret_key_bytes, message_bytes, hashlib.sha256).digest()
        signature = base64.b64encode(sign).decode('utf-8')
        return signature

# ì¶”ê°€ì ìœ¼ë¡œ í•„ìš”í•œ í•¨ìˆ˜ë“¤ë„ ì—¬ê¸°ì— êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë³€ê²½ ì‚¬í•­ ë° ê°œì„  ì‚¬í•­ ìš”ì•½:
UI ê°œì„ :

ì¢Œì¸¡ì˜ ë¸”ë¡œê·¸ ì‘ì„± ê¸°ëŠ¥ê³¼ ìš°ì¸¡ì˜ í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ë¥¼ 2:1 ë¹„ìœ¨ë¡œ ë‚˜ëˆ  ë” ë„“ì€ í™”ë©´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.
í…ìŠ¤íŠ¸ êµµê²Œ í‘œì‹œ ë° ì´ëª¨í‹°ì½˜ ì¶”ê°€ ê¸°ëŠ¥ì„ ìœ ì§€í–ˆìŠµë‹ˆë‹¤.
í‚¤ì›Œë“œ ë¶„ì„:

ì…ë ¥í•œ í‚¤ì›Œë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë„¤ì´ë²„ APIë¥¼ ì‚¬ìš©í•´ í‚¤ì›Œë“œ ë¶„ì„ì„ ì‹¤í–‰í•˜ê³ , ê·¸ ê²°ê³¼ë¥¼ ìš°ì¸¡ ì—´ì— í‘œì‹œí•©ë‹ˆë‹¤.
ê²°ê³¼ëŠ” pd.DataFrame í˜•íƒœë¡œ ë¶„ì„ëœ í‚¤ì›Œë“œë¥¼ í¬í•¨í•´ í‘œ í˜•íƒœë¡œ ì¶œë ¥ë©ë‹ˆë‹¤.
ì´ëª¨í‹°ì½˜ ì¶”ê°€:

ë‹¤ì–‘í•œ ì´ëª¨í‹°ì½˜ì„ ë²„íŠ¼ í´ë¦­ìœ¼ë¡œ ë¸”ë¡œê·¸ ê¸€ì— ì‚½ì…í•  ìˆ˜ ìˆê²Œ í–ˆìŠµë‹ˆë‹¤.
ì „ì²´ íë¦„:

í…ìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ê³ , í‚¤ì›Œë“œ ë¶„ì„ì„ ì‹¤í–‰í•˜ê³ , ì‹¤ì‹œê°„ìœ¼ë¡œ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆëŠ” ì‘ì—… íë¦„ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
requirements.txt
txt
ì½”ë“œ ë³µì‚¬
streamlit
pandas
requests
ì´ ì½”ë“œëŠ” í•„ìš”í•œ Python íŒ¨í‚¤ì§€ë“¤ì„ ì„¤ì¹˜í•˜ì—¬ ì•±ì´ ì •ìƒ ì‘ë™í•˜ë„ë¡ í•´ì¤ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì™„ë²½í•œ ì½”ë“œì•¼?
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì½”ë“œë¥¼ ì „ë°˜ì ìœ¼ë¡œ ê²€í† í•œ ê²°ê³¼, ë‹¤ìŒê³¼ ê°™ì€ ìš”ì†Œë“¤ì´ í¬í•¨ë˜ì–´ ìˆì–´ ì£¼ìš” ê¸°ëŠ¥ë“¤ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•  ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤:

í‚¤ì›Œë“œ ë¶„ì„ ë° ë¸”ë¡œê·¸ ì‘ì„±: ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ì›Œë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ API í˜¸ì¶œì„ í†µí•´ ë¶„ì„ ê²°ê³¼ë¥¼ ê°€ì ¸ì˜¤ê³ , ë¸”ë¡œê·¸ ê¸€ ì‘ì„± ê¸°ëŠ¥ì´ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤.

UI êµ¬ì„±: Streamlitì„ ì´ìš©í•œ 2:1 ë ˆì´ì•„ì›ƒìœ¼ë¡œ ì¢Œì¸¡ì€ ë¸”ë¡œê·¸ ì‘ì„±ê³¼ í‚¤ì›Œë“œ ì…ë ¥, ìš°ì¸¡ì€ í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ì´ëª¨í‹°ì½˜ ì¶”ê°€: ì´ëª¨í‹°ì½˜ì„ ë¸”ë¡œê·¸ ê¸€ì— ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìˆê³ , í‚¤ì›Œë“œ êµµê²Œ í‘œì‹œ ê¸°ëŠ¥ë„ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ ëª‡ ê°€ì§€ ì ê²€í•  ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤:

ì ê²€ ì‚¬í•­
BASE_URL ì •ì˜: get_keyword_analysis() í•¨ìˆ˜ ë‚´ì—ì„œ BASE_URLì´ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì´ ë¶€ë¶„ì„ ì½”ë“œ ìƒë‹¨ì— ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆì‹œë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

python
ì½”ë“œ ë³µì‚¬
BASE_URL = "https://api.naver.com"  # ì‹¤ì œ APIì˜ ê¸°ë³¸ URLì„ ë„£ì–´ì•¼ í•¨
API Key ë° Signature ìƒì„±: API í˜¸ì¶œì„ ìœ„í•œ ì‹œê·¸ë‹ˆì²˜ ìƒì„± í•¨ìˆ˜ëŠ” ì •í™•í•´ ë³´ì´ë‚˜, API í˜¸ì¶œì´ ì˜ëª»ëœ í‚¤ë¡œ ì¸í•´ ì‹¤íŒ¨í•  ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤. ì‹¤ì œ API í‚¤ì™€ SECRET_KEYê°€ ì •í™•í•œì§€ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

ì´ëª¨í‹°ì½˜ ì¶”ê°€: ì‚¬ìš©ìê°€ ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•  ë•Œ ìƒˆë¡œìš´ ì´ëª¨í‹°ì½˜ì´ ê¸°ì¡´ í…ìŠ¤íŠ¸ì— ì¶”ê°€ë˜ì§€ ì•Šê³  ë®ì–´ì”Œì›Œì§ˆ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ í…ìŠ¤íŠ¸ë¥¼ ê°±ì‹ í•  ë•Œ ê¸°ì¡´ ì…ë ¥ëœ í…ìŠ¤íŠ¸ì— ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•˜ë„ë¡ ìˆ˜ì •í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í‚¤ì›Œë“œ ë¶„ì„ ì˜¤ë¥˜ ì²˜ë¦¬: API í˜¸ì¶œ ì‹¤íŒ¨ ì‹œì— ëŒ€ë¹„í•œ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ë” ê°•í™”ë˜ë©´ ì¢‹ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, API ìš”ì²­ì´ ì‹¤íŒ¨í–ˆì„ ë•Œ ì‚¬ìš©ìì—ê²Œ ì ì ˆí•œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

python
ì½”ë“œ ë³µì‚¬
if r.status_code != 200:
    st.error(f"í‚¤ì›Œë“œ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ì—ëŸ¬ ì½”ë“œ: {r.status_code})")
    return pd.DataFrame()
ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥: ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ì„ HTMLë¡œ ë Œë”ë§í•˜ê³  ìˆìœ¼ë¯€ë¡œ, HTML ë§ˆí¬ì—…ì´ ì •í™•í•˜ê²Œ ë™ì‘í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ st.markdown() í•¨ìˆ˜ì—ì„œ í…ìŠ¤íŠ¸ê°€ ì œëŒ€ë¡œ í‘œì‹œë˜ëŠ”ì§€ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

ìœ„ ì‚¬í•­ì„ ë°˜ì˜í•œ ë’¤ì—, í…ŒìŠ¤íŠ¸ë¥¼ í†µí•´ API í˜¸ì¶œ ë° ë¶„ì„ ê²°ê³¼ ì¶œë ¥ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•˜ë©´ ì™„ë²½í•œ ì½”ë“œì— ê°€ê¹Œì›Œì§ˆ ê²ƒì…ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
File "/home/adminuser/venv/lib/python3.12/site-packages/streamlit/runtime/scriptrunner/exec_code.py", line 88, in exec_func_with_error_handling
    result = func()
             ^^^^^^
File "/home/adminuser/venv/lib/python3.12/site-packages/streamlit/runtime/scriptrunner/script_runner.py", line 579, in code_to_exec
    exec(code, module.__dict__)
File "/mount/src/seeyourightnow/steamlit_app.py", line 68, in <module>
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì—ëŸ¬ ë©”ì‹œì§€ê°€ steamlit_app.pyì˜ 68ë²ˆì§¸ ì¤„ì—ì„œ ë°œìƒí•˜ê³  ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê²ƒì€ exec(code, module.__dict__)ì—ì„œ codeê°€ ì‹¤í–‰ë  ë•Œ, íŠ¹ì • ì½”ë“œ ë¼ì¸ì´ ë¬¸ì œë¥¼ ì¼ìœ¼í‚¤ê³  ìˆë‹¤ëŠ” ì ì…ë‹ˆë‹¤.

ë‹¤ìŒì€ ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸ì™€ ì ‘ê·¼ ë°©ë²•ì…ë‹ˆë‹¤:

1. ì˜¤ë¥˜ê°€ ë°œìƒí•œ ìœ„ì¹˜ íŒŒì•…:
ì—ëŸ¬ê°€ ë°œìƒí•œ ì½”ë“œì˜ 68ë²ˆì§¸ ì¤„ì„ í™•ì¸í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤. ì½”ë“œì˜ í•´ë‹¹ ë¶€ë¶„ì—ì„œ ì–´ë–¤ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³  ìˆëŠ”ì§€, í˜¹ì€ ì–´ë–¤ ë¡œì§ì´ ì‹¤í–‰ë˜ê³  ìˆëŠ”ì§€ë¥¼ ì¤‘ì ì ìœ¼ë¡œ ì‚´í´ì•¼ í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì´ëŸ° ì¢…ë¥˜ì˜ ì—ëŸ¬ëŠ” ë¯¸ì •ì˜ ë³€ìˆ˜, ì˜ëª»ëœ í•¨ìˆ˜ í˜¸ì¶œ, ë˜ëŠ” ì™¸ë¶€ API ìš”ì²­ê³¼ ê´€ë ¨ëœ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´:

python
ì½”ë“œ ë³µì‚¬
df = get_keyword_analysis(keyword)  # ì´ì „ì— êµ¬í˜„ëœ í‚¤ì›Œë“œ ë¶„ì„ í•¨ìˆ˜
ì´ ë¶€ë¶„ì—ì„œ get_keyword_analysis í•¨ìˆ˜ê°€ ì œëŒ€ë¡œ í˜¸ì¶œë˜ì§€ ì•Šì•˜ê±°ë‚˜, í•¨ìˆ˜ ë‚´ì—ì„œ ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜ë¥¼ ì°¸ì¡°í•˜ê³  ìˆì„ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.

2. BASE_URL ì •ì˜ ì—¬ë¶€ í™•ì¸:
get_keyword_analysis() í•¨ìˆ˜ ë‚´ì—ì„œ API í˜¸ì¶œì„ ìˆ˜í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ë•Œ **BASE_URL**ì´ ì œëŒ€ë¡œ ì •ì˜ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. BASE_URLì„ ì½”ë“œ ìƒë‹¨ì— ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:

python
ì½”ë“œ ë³µì‚¬
BASE_URL = "https://api.naver.com"  # ì‹¤ì œ ì‚¬ìš© ì¤‘ì¸ APIì˜ URLë¡œ ë³€ê²½í•´ì•¼ í•¨
3. API í˜¸ì¶œ ë° ì‘ë‹µ í™•ì¸:
API í˜¸ì¶œ ì‹œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì´ ìš”ì²­ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”:

python
ì½”ë“œ ë³µì‚¬
r = requests.get(
    BASE_URL + uri,
    params={'hintKeywords': keyword, 'showDetail': 1},
    headers=get_request_header(method, uri)
)

if r.status_code != 200:
    st.error(f"API í˜¸ì¶œ ì‹¤íŒ¨: {r.status_code}, ì‘ë‹µ ë©”ì‹œì§€: {r.text}")
    return pd.DataFrame()  # ë¹ˆ ë°ì´í„°í”„ë ˆì„ ë°˜í™˜
4. ë°ì´í„° ì²˜ë¦¬ ë¡œì§ ì ê²€:
get_keyword_analysis() í•¨ìˆ˜ ë‚´ì—ì„œ DataFrame ì²˜ë¦¬ ê³¼ì •ì— ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë°ì´í„°ì˜ íŠ¹ì • í•„ë“œì— ê°’ì´ ì—†ê±°ë‚˜ ì˜ˆìƒí•˜ì§€ ëª»í•œ í˜•ì‹ì¼ ê²½ìš° ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° í•„ë“œì— ëŒ€í•´ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

python
ì½”ë“œ ë³µì‚¬
if 'keywordList' not in r.json():
    st.error("API ì‘ë‹µì— 'keywordList'ê°€ ì—†ìŠµë‹ˆë‹¤.")
    return pd.DataFrame()  # ë¹ˆ ë°ì´í„°í”„ë ˆì„ ë°˜í™˜
5. ì½˜ì†” ë¡œê·¸ ë° ë””ë²„ê¹…:
ì¶”ê°€ì ìœ¼ë¡œ, ë””ë²„ê¹…ì„ ìœ„í•´ ì¤‘ê°„ì¤‘ê°„ st.write() ë˜ëŠ” print() ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ í•¨ìˆ˜ì—ì„œ ì–´ë–¤ ê°’ì´ ë°˜í™˜ë˜ëŠ”ì§€, ì–´ë””ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ”ì§€ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

python
ì½”ë“œ ë³µì‚¬
st.write(r.json())  # API ì‘ë‹µì„ í™•ì¸
6. Streamlit ë° API ì˜ì¡´ì„± ë²„ì „ í™•ì¸:
requirements.txt íŒŒì¼ì—ì„œ ì‚¬ìš©í•˜ëŠ” íŒ¨í‚¤ì§€ë“¤ì˜ ë²„ì „ì„ í™•ì¸í•˜ì—¬ í˜¸í™˜ì„± ë¬¸ì œë¥¼ ì ê²€í•´ì•¼ í•©ë‹ˆë‹¤. requests, streamlit, pandas ë“± ìµœì‹  ë²„ì „ê³¼ í˜¸í™˜ì„±ì´ ë§ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

ì´ ë‹¨ê³„ë¥¼ í†µí•´ ì–´ë””ì„œ ë¬¸ì œê°€ ë°œìƒí–ˆëŠ”ì§€ë¥¼ ë” ëª…í™•í•˜ê²Œ íŒŒì•…í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤. 68ë²ˆì§¸ ì¤„ì˜ êµ¬ì²´ì ì¸ ì½”ë“œì™€ í•¨ê»˜ ì¶”ê°€ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ë” ê¹Šì´ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
import streamlit as st
import pandas as pd
import requests
import re
import time
import hmac
import hashlib
import base64
import pyperclip

# í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# st.secretsì—ì„œ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸°
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# Constants
BASE_URL = "https://api.naver.com"

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = f"{timestamp}.{method}.{uri}"
        secret_key_bytes = bytes(secret_key, 'utf-8')
        message_bytes = bytes(message, 'utf-8')
        sign = hmac.new(secret_key_bytes, message_bytes, hashlib.sha256).digest()
        signature = base64.b64encode(sign).decode('utf-8')
        return signature

def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    try:
        r = requests.get(
            BASE_URL + uri,
            params={'hintKeywords': keyword, 'showDetail': 1},
            headers=get_request_header(method, uri)
        )
        r.raise_for_status()
        data = r.json()
        
        if 'keywordList' not in data:
            st.error(f"API ì‘ë‹µì— 'keywordList'ê°€ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ: {data}")
            return pd.DataFrame()
        
        df = pd.DataFrame(data['keywordList'])
        if df.empty:
            st.warning(f"'{keyword}'ì— ëŒ€í•œ í‚¤ì›Œë“œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return df
        
        # ë°ì´í„° ì²˜ë¦¬ ë¶€ë¶„ì„ try-exceptë¡œ ê°ì‹¸ ì˜¤ë¥˜ ì²˜ë¦¬
        try:
            df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
            df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
            df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
            df.rename(
                {'compIdx': 'ê²½ìŸì •ë„',
                'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
                'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
                'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
                axis=1,
                inplace=True
            )
            df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
            df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
        except Exception as e:
            st.error(f"ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return pd.DataFrame()
        
        return df
    except requests.RequestException as e:
        st.error(f"API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return pd.DataFrame()
    except Exception as e:
        st.error(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return pd.DataFrame()

# êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ
adsense_codes = {
    "êµ¬ë¼ë‹¤": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>""",
    "ë¸”ë¡œê·¸ìŠ¤íŒŸ": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>""",
    "ë¯¸ë¼í´E": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>"""
}

# ë°˜ì§ì´ëŠ” ë²„íŠ¼ HTML ìƒì„± í•¨ìˆ˜
def create_glowing_button(text, link):
    return f"""
<style>
.glow-on-hover {{
    width: 220px;
    height: 50px;
    border: none;
    outline: none;
    color: #fff;
    background: #111;
    cursor: pointer;
    position: relative;
    z-index: 0;
    border-radius: 10px;
}}
.glow-on-hover:before {{
    content: '';
    background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
    position: absolute;
    top: -2px;
    left:-2px;
    background-size: 400%;
    z-index: -1;
    filter: blur(5px);
    width: calc(100% + 4px);
    height: calc(100% + 4px);
    animation: glowing 20s linear infinite;
    opacity: 0;
    transition: opacity .3s ease-in-out;
    border-radius: 10px;
}}
.glow-on-hover:active {{
    color: #000
}}
.glow-on-hover:active:after {{
    background: transparent;
}}
.glow-on-hover:hover:before {{
    opacity: 1;
}}
.glow-on-hover:after {{
    z-index: -1;
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: #111;
    left: 0;
    top: 0;
    border-radius: 10px;
}}
@keyframes glowing {{
    0% {{ background-position: 0 0; }}
    50% {{ background-position: 400% 0; }}
    100% {{ background-position: 0 0; }}
}}
</style>
<a href="{link}" target="_blank">
    <button class="glow-on-hover" type="button">{text}</button>
</a>
"""

# ë©”ì¸ ë ˆì´ì•„ì›ƒ ì„¤ì •
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ ë²„íŠ¼
st.subheader("êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ")
for name, code in adsense_codes.items():
    if st.button(f"{name} ê´‘ê³  ì½”ë“œ ë³µì‚¬"):
        st.code(code, language='html')
        st.success(f"{name} ê´‘ê³  ì½”ë“œê°€ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”.")

# ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„±
st.subheader("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„±")
button_text = st.text_input("ë²„íŠ¼ í…ìŠ¤íŠ¸ ì…ë ¥")
button_link = st.text_input("ë²„íŠ¼ ë§í¬ ì…ë ¥")
if st.button("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ì½”ë“œ ìƒì„±"):
    button_code = create_glowing_button(button_text, button_link)
    st.code(button_code, language='html')
    st.success("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ì½”ë“œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ„ì˜ ì½”ë“œë¥¼ ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”.")
    st.markdown(button_code, unsafe_allow_html=True)

# ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
st.subheader("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# í‚¤ì›Œë“œ ë¶„ì„
keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt, ì¸ê³µì§€ëŠ¥').split(',')
keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

# ì´ëª¨í‹°ì½˜ ì¶”ê°€ ë²„íŠ¼
emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
cols = st.columns(len(emoji_list))
for idx, (emoji, emoji_symbol) in enumerate(emoji_list):
    with cols[idx]:
        if st.button(emoji):
            input_text += emoji_symbol
            st.experimental_rerun()

# í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
if text_format == "HTML":
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)
elif text_format == "Markdown":
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'**\1**', input_text)

# ì‘ì„±ëœ ê¸€ ë¯¸ë¦¬ë³´ê¸°
st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
if text_format == "HTML":
    st.markdown(input_text, unsafe_allow_html=True)
elif text_format == "Markdown":
    st.markdown(input_text)
else:
    st.text(input_text)

# í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
st.subheader("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")
if st.button('ë¶„ì„ ì‹¤í–‰'):
    tmp_df = pd.DataFrame()
    with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
        for keyword in keywords:
            keyword = keyword.strip()
            if keyword:
                df = get_keyword_analysis(keyword)
                if not df.empty:
                    tmp_df = pd.concat([tmp_df, df], axis=0)
    if not tmp_df.empty:
        st.dataframe(tmp_df)
    else:
        st.warning("ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. í‚¤ì›Œë“œë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.")
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì½”ë“œê°€ ì™„ì„±ë˜ì—ˆìœ¼ë©°, ê¸°ëŠ¥ì ìœ¼ë¡œ ì˜ ë™ì‘í•  ê²ƒì…ë‹ˆë‹¤. ì´ì œ ì „ì²´ì ì¸ êµ¬ì„±ì„ ë‹¤ì‹œ ì ê²€í•´ë³´ê² ìŠµë‹ˆë‹¤:

ì£¼ìš” ê¸°ëŠ¥:
í˜ì´ì§€ ë ˆì´ì•„ì›ƒ ì„¤ì •:

st.set_page_config()ë¡œ í˜ì´ì§€ë¥¼ ë„“ê²Œ ì„¤ì •.
API ìš”ì²­ ë° í‚¤ì›Œë“œ ë¶„ì„:

ë„¤ì´ë²„ í‚¤ì›Œë“œ íˆ´ APIë¥¼ í™œìš©í•œ í‚¤ì›Œë“œ ë¶„ì„ ê¸°ëŠ¥.
ìºì‹œ(@st.cache_data)ë¥¼ í™œìš©í•˜ì—¬ API ê²°ê³¼ë¥¼ ìºì‹œ.
monthlyMobileQcCnt, monthlyPcQcCnt í•„í„°ë§ ê¸°ëŠ¥ í¬í•¨.
êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ ë³µì‚¬:

adsense_codes ë”•ì…”ë„ˆë¦¬ë¥¼ í†µí•´ ì—¬ëŸ¬ êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œë¥¼ ë³µì‚¬í•  ìˆ˜ ìˆìŒ.
ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„±:

ì‚¬ìš©ìê°€ í…ìŠ¤íŠ¸ì™€ ë§í¬ë¥¼ ì…ë ¥í•˜ë©´ ë°˜ì§ì´ëŠ” ë²„íŠ¼ì„ ìƒì„±í•˜ëŠ” HTML ì½”ë“œë¥¼ ì œê³µ.
ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸:

ì‚¬ìš©ìì—ê²Œ ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•˜ë©°, HTML ë˜ëŠ” Markdown í˜•ì‹ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì‘ì„± ê°€ëŠ¥.
íŠ¹ì • í‚¤ì›Œë“œë¥¼ êµµê²Œ í‘œì‹œí•˜ê³ , ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•˜ëŠ” ê¸°ëŠ¥ë„ í¬í•¨.
í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ í‘œì‹œ:

ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥ë°›ê³  ë„¤ì´ë²„ APIë¥¼ í†µí•´ ë¶„ì„í•˜ì—¬ ê²°ê³¼ë¥¼ í‘œë¡œ ì¶œë ¥.
ì£¼ìš” ì—…ë°ì´íŠ¸/ìˆ˜ì • ì‚¬í•­:
API í‚¤ ë³´ì•ˆ ì²˜ë¦¬: st.secretsì—ì„œ API í‚¤ë¥¼ ë¶ˆëŸ¬ì™€ ë³´ì•ˆ ì²˜ë¦¬.
API ì˜¤ë¥˜ ì²˜ë¦¬: ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•  ê²½ìš°, ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ í†µí•´ ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ ì œê³µ.
ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜ ëŒ€ì‘: í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼ì— ëŒ€í•œ ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ í”„ë¡œê·¸ë¨ì´ ë©ˆì¶”ì§€ ì•Šë„ë¡ ì²˜ë¦¬.
ì¶”ê°€ ê³ ë ¤ ì‚¬í•­:
ì„±ëŠ¥ ê°œì„ :

@st.cache_data ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•´ ìºì‹± ì²˜ë¦¬ë¡œ API ìš”ì²­ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤. ê²°ê³¼ê°€ ìì£¼ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê²½ìš°, ìºì‹œë¥¼ ì ì ˆíˆ í™œìš©í•˜ì—¬ ì„±ëŠ¥ì„ ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ìœ ì € ì¸í„°í˜ì´ìŠ¤ ê°œì„ :

ì´ëª¨í‹°ì½˜ ì¶”ê°€ ê¸°ëŠ¥, ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„± ê¸°ëŠ¥ì„ í†µí•´ ë¸”ë¡œê·¸ ì‘ì„±ì„ ë³´ë‹¤ ì¦ê²ê³  ì§ê´€ì ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
API ì‘ë‹µì˜ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬:

get_keyword_analysis í•¨ìˆ˜ì—ì„œ ì‘ë‹µ ë°ì´í„°ë¥¼ ì² ì €íˆ ê²€ì‚¬í•˜ê³ , í•„ë“œê°€ ë¹„ì—ˆê±°ë‚˜ í˜•ì‹ì´ ë§ì§€ ì•Šìœ¼ë©´ ê²½ê³  ë©”ì‹œì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
ì´ì œ ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸í•˜ë©´ì„œ ê° ê¸°ëŠ¥ì´ ì œëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•˜ì‹œë©´ ë©ë‹ˆë‹¤. íŠ¹íˆ, API ìš”ì²­ì´ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ìš°ì„  html ë§ˆí¬ë‹¤ìš´ ì¼ë°˜í…ìŠ¤íŠ¸ë¥¼ í´ë¦­í• ë•Œ ë§ˆë‹¤ ìƒíƒœì— ë§ê²Œ ë³€í™”í•´ì•¼ì§€. ì˜ˆë¥¼ ë“¤ì–´ì„œ ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ì‘ì„±í–ˆë‹¤ê°€ htmlë¡œ ëˆ„ë¥´ë©´ htmlì— ë§ê²Œ ë³´ì—¬ì•¼ í•œë‹¤!. ìš°ì„  ê¸€ì€ h1ì€ ëª»ì“°ê²Œ ë§‰ì•„ ë†“ê³  ë“œë˜ê·¸ë¡œ ì„ íƒí•´ì„œ ê¸€ìë¥¼ ë³¸ë¬¸, h2, h3 ì„¸ê°€ì§€ ì¤‘ì—ì„œë§Œ ì„ íƒí•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‚˜? ì¼ë°˜ í…ìŠ¤íŠ¸ í¸ì§‘ê¸° ì²˜ëŸ¼ ë§ì´ì•¼
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
Streamlitì—ì„œ ì œê³µí•˜ëŠ” ê¸°ë³¸ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ë¡œëŠ” ë“œë˜ê·¸í•´ì„œ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ì„ ë°”ê¾¸ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê¸°ê°€ ì–´ë ¤ìš¸ ìˆ˜ ìˆì§€ë§Œ, ëŒ€ì•ˆì„ ì œê³µí•  ìˆ˜ ìˆëŠ” ëª‡ ê°€ì§€ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ëŠ” ê°ê°ì˜ ê¸°ëŠ¥ì„ ì–´ë–»ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆëŠ”ì§€ì— ëŒ€í•œ ì œì•ˆì…ë‹ˆë‹¤:

1. Markdown/HTML/Plain Text ì „í™˜ ê¸°ëŠ¥:
í…ìŠ¤íŠ¸ í˜•ì‹ì„ ì„ íƒí•  ë•Œë§ˆë‹¤ ìë™ìœ¼ë¡œ í•´ë‹¹ í˜•ì‹ì— ë§ì¶° í…ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ì‹.
ì‚¬ìš©ìê°€ Markdownìœ¼ë¡œ ì‘ì„±í•˜ë‹¤ê°€ HTMLë¡œ ì „í™˜í•˜ë©´ ì¦‰ì‹œ HTML í˜•ì‹ìœ¼ë¡œ ë³€í™˜ëœ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ê¸°ëŠ¥.
2. H1 íƒœê·¸ ì°¨ë‹¨ ë° í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì„ íƒ:
H1 íƒœê·¸ëŠ” ì°¨ë‹¨í•˜ê³ , ë“œë˜ê·¸í•œ í…ìŠ¤íŠ¸ì— ëŒ€í•´ ë³¸ë¬¸, H2, H3 ì¤‘ í•˜ë‚˜ë¡œ ìŠ¤íƒ€ì¼ì„ ì§€ì •í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„.
ì¼ë°˜ í…ìŠ¤íŠ¸ í¸ì§‘ê¸°ì²˜ëŸ¼ ë“œë˜ê·¸ë¡œ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ì„ ë°”ê¿€ ìˆ˜ëŠ” ì—†ì§€ë§Œ, í…ìŠ¤íŠ¸ ë¸”ë¡ì„ ì„ íƒí•˜ì—¬ ë³¸ë¬¸, H2, H3ìœ¼ë¡œ ì§€ì •í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì½”ë“œ êµ¬í˜„ ì œì•ˆ
í…ìŠ¤íŠ¸ í˜•ì‹ ì „í™˜ ê¸°ëŠ¥: í…ìŠ¤íŠ¸ í˜•ì‹ì„ ë°”ê¾¸ë©´ ìë™ìœ¼ë¡œ í•´ë‹¹ í˜•ì‹ìœ¼ë¡œ ë³€í™˜ëœ ê²°ê³¼ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

H1 íƒœê·¸ ì°¨ë‹¨ ë° í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì„ íƒ: ì„ íƒí•œ í…ìŠ¤íŠ¸ ë¸”ë¡ì— ìŠ¤íƒ€ì¼ì„ ì§€ì •í•  ìˆ˜ ìˆëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„.

python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import re

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ
st.subheader("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))

# ê¸€ ì‘ì„± ì…ë ¥
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# H1 íƒœê·¸ ì‚¬ìš© ì œí•œ
def block_h1_tags(text):
    # HTML í˜•ì‹ì—ì„œ H1 íƒœê·¸ë¥¼ ì°¨ë‹¨
    text = re.sub(r'<h1[^>]*>.*?</h1>', '', text, flags=re.IGNORECASE)
    # Markdown í˜•ì‹ì—ì„œ #ì„ ì‚¬ìš©í•œ H1ì„ ì°¨ë‹¨
    text = re.sub(r'^# .+', '', text, flags=re.MULTILINE)
    return text

# í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì ìš© (ë³¸ë¬¸, H2, H3)
def apply_text_style(style, selected_text, text):
    if style == "H2":
        return text.replace(selected_text, f"<h2>{selected_text}</h2>")
    elif style == "H3":
        return text.replace(selected_text, f"<h3>{selected_text}</h3>")
    else:
        return text.replace(selected_text, f"<p>{selected_text}</p>")

# ì„ íƒëœ í…ìŠ¤íŠ¸ì— ìŠ¤íƒ€ì¼ ì ìš© ê¸°ëŠ¥ ì¶”ê°€
selected_style = st.selectbox("ì„ íƒí•œ í…ìŠ¤íŠ¸ì— ìŠ¤íƒ€ì¼ ì ìš©", ["ë³¸ë¬¸", "H2", "H3"])
selected_text = st.text_input("ìŠ¤íƒ€ì¼ì„ ì ìš©í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”")

if st.button("ìŠ¤íƒ€ì¼ ì ìš©"):
    input_text = apply_text_style(selected_style, selected_text, input_text)
    st.success("ìŠ¤íƒ€ì¼ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.")

# H1 íƒœê·¸ ì°¨ë‹¨
input_text = block_h1_tags(input_text)

# í…ìŠ¤íŠ¸ í˜•ì‹ì— ë”°ë¥¸ ì¶œë ¥
st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
if text_format == "HTML":
    st.markdown(input_text, unsafe_allow_html=True)
elif text_format == "Markdown":
    st.markdown(input_text)
else:
    st.text(input_text)
ì„¤ëª…:
H1 íƒœê·¸ ì°¨ë‹¨:

block_h1_tags() í•¨ìˆ˜ì—ì„œ HTMLê³¼ Markdownì—ì„œ H1 íƒœê·¸ë¥¼ ì°¨ë‹¨í•©ë‹ˆë‹¤.
HTMLì—ì„œëŠ” <h1> íƒœê·¸ë¥¼, Markdownì—ì„œëŠ” #ì„ ì‚¬ìš©í•œ H1 ë¬¸ë²•ì„ ì œê±°í•©ë‹ˆë‹¤.
ìŠ¤íƒ€ì¼ ì„ íƒ:

ë“œë˜ê·¸ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì§€ëŠ” ì•Šì•˜ì§€ë§Œ, ì‚¬ìš©ìê°€ ì„ íƒí•œ í…ìŠ¤íŠ¸ì— ëŒ€í•´ ë³¸ë¬¸, H2, H3ìœ¼ë¡œ ìŠ¤íƒ€ì¼ì„ ì ìš©í•  ìˆ˜ ìˆë„ë¡ ì„ íƒë°•ìŠ¤ë¥¼ ì œê³µí–ˆìŠµë‹ˆë‹¤.
ì‚¬ìš©ìê°€ í…ìŠ¤íŠ¸ ë¸”ë¡ì„ ì„ íƒí•˜ê³  ì›í•˜ëŠ” ìŠ¤íƒ€ì¼ì„ ì§€ì •í•˜ë©´ apply_text_style() í•¨ìˆ˜ì—ì„œ í•´ë‹¹ ìŠ¤íƒ€ì¼ì„ ì ìš©í•©ë‹ˆë‹¤.
í…ìŠ¤íŠ¸ í˜•ì‹ ë³€í™˜:

ì‚¬ìš©ìê°€ Markdownìœ¼ë¡œ ì‘ì„±í•œ í›„ HTML í˜•ì‹ìœ¼ë¡œ ì „í™˜í•˜ë©´, ì¦‰ì‹œ HTMLë¡œ ë³€í™˜ëœ ê²°ê³¼ë¥¼ ë¯¸ë¦¬ë³´ê¸°ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë°˜ëŒ€ë¡œ ì¼ë°˜ í…ìŠ¤íŠ¸ë‚˜ ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œë„ ì „í™˜ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
ì´ ì½”ë“œë¥¼ ë°”íƒ•ìœ¼ë¡œ ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ì¡°ê¸ˆ ë” ì»¤ìŠ¤í„°ë§ˆì´ì§•í•˜ì—¬ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ìš°ì„  html ë§ˆí¬ë‹¤ìš´ ì¼ë°˜í…ìŠ¤íŠ¸ë¥¼ í´ë¦­í• ë•Œ ë§ˆë‹¤ ìƒíƒœì— ë§ê²Œ ë³€í™”í•´ì•¼ì§€. ì˜ˆë¥¼ ë“¤ì–´ì„œ ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ì‘ì„±í–ˆë‹¤ê°€ htmlë¡œ ëˆ„ë¥´ë©´ htmlì— ë§ê²Œ ë³´ì—¬ì•¼ í•œë‹¤!. ìš°ì„  ê¸€ì€ h1ì€ ëª»ì“°ê²Œ ë§‰ì•„ ë†“ê²Œë§Œ í•˜ê³ . h1ì´ ë³´ì´ë©´ ë¬´ì¡°ê±´ h2ë¡œ ë°”ë€Œê²Œë§Œ í•˜ì. ë‚˜ë¨¸ì§€ í…ìŠ¤íŠ¸ í¸ì§‘ê¸°ëŠ” í•„ìš” ì—†ì„ ê²ƒ ê°™ë‹¤.
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ë„¤, ë§ì”€í•˜ì‹  ìš”êµ¬ì‚¬í•­ì— ë§ê²Œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì—¬ Markdownìœ¼ë¡œ ì‘ì„±í•œ ê¸€ì´ HTMLë¡œ ì „í™˜ë  ë•Œ ë³€í™˜ëœ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ê³ , H1 íƒœê·¸ëŠ” ìë™ìœ¼ë¡œ H2ë¡œ ë³€í™˜ë˜ê²Œ êµ¬í˜„í•´ë³´ê² ìŠµë‹ˆë‹¤. ë‚˜ë¨¸ì§€ í…ìŠ¤íŠ¸ í¸ì§‘ê¸° ê¸°ëŠ¥ì€ ì œì™¸í•˜ê³ , H1 íƒœê·¸ë§Œ ìë™ìœ¼ë¡œ H2ë¡œ ë³€ê²½ë˜ëŠ” ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ë³€í™˜ ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

ì£¼ìš” ê¸°ëŠ¥:
Markdown/HTML/Plain Text ì „í™˜ ì‹œ í…ìŠ¤íŠ¸ ìë™ ë³€í™˜:
ì‚¬ìš©ìê°€ Markdownìœ¼ë¡œ ì‘ì„±í•œ í›„ HTMLë¡œ ì „í™˜í•˜ë©´ í•´ë‹¹ í˜•ì‹ìœ¼ë¡œ ìë™ ë³€í™˜í•˜ì—¬ ì¶œë ¥í•©ë‹ˆë‹¤.
Plain Text í˜•ì‹ë„ ì „í™˜ ê°€ëŠ¥í•©ë‹ˆë‹¤.
H1 íƒœê·¸ ì°¨ë‹¨:
H1 íƒœê·¸ëŠ” ì°¨ë‹¨í•˜ê³ , ìë™ìœ¼ë¡œ H2ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
ì½”ë“œ êµ¬í˜„:
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import re

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ
st.subheader("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))

# ê¸€ ì‘ì„± ì…ë ¥
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# H1 íƒœê·¸ë¥¼ H2ë¡œ ë³€í™˜
def convert_h1_to_h2(text, format_type):
    if format_type == "HTML":
        # HTMLì˜ <h1> íƒœê·¸ë¥¼ <h2>ë¡œ ë³€ê²½
        text = re.sub(r'<h1[^>]*>(.*?)<\/h1>', r'<h2>\1</h2>', text, flags=re.IGNORECASE)
    elif format_type == "Markdown":
        # Markdownì˜ H1 ë¬¸ë²•ì„ H2 ë¬¸ë²•ìœ¼ë¡œ ë³€ê²½ (# -> ##)
        text = re.sub(r'^# (.+)', r'## \1', text, flags=re.MULTILINE)
    return text

# í…ìŠ¤íŠ¸ í˜•ì‹ì— ë§ê²Œ ë³€í™˜
if text_format == "HTML":
    # HTML í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    input_text = convert_h1_to_h2(input_text, "HTML")
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸° (HTML):")
    st.markdown(input_text, unsafe_allow_html=True)

elif text_format == "Markdown":
    # Markdown í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    input_text = convert_h1_to_h2(input_text, "Markdown")
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸° (Markdown):")
    st.markdown(input_text)

else:
   
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
Markdown/HTML/Plain Text ì „í™˜ ì‹œ í…ìŠ¤íŠ¸ ìë™ ë³€í™˜:
ì‚¬ìš©ìê°€ Markdownìœ¼ë¡œ ì‘ì„±í•œ í›„ HTMLë¡œ ì „í™˜í•˜ë©´ í•´ë‹¹ í˜•ì‹ìœ¼ë¡œ ìë™ ë³€í™˜í•˜ì—¬ ì¶œë ¥í•©ë‹ˆë‹¤. ì´ê±´ ì´ ë‘ê°œë§Œ ê·¸ëŸ¬ëŠ”ê²Œ ì•„ë‹ˆë¼ ì„œë¡œ ëˆ„ë¥¼ ë•Œ ë§ˆë‹¤ ê·¸ì–‘ì‹ëŒ€ë¡œ ë³´ì—¬ì•¼ í•œë‹¤. ì˜ˆë¥¼ë“¤ì–´ì„œ ì¼ë°˜í…ìŠ¤íŠ¸ë¡œ ì‘ì„±í•˜ë‹¤ê°€ë„ htmlì„ ëˆ„ë¥´ë©´ html í˜•íƒœë¡œ ë‚˜ì™€ì•¼í•œë‹¤.ê¸€ì˜ ì–‘ì‹ì—ëŠ” ë³¸ë¬¸ê³¼ h2 ë§Œ í—ˆìš©ì´ ëœë‹¤
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì´ì œ ë§ì”€í•˜ì‹  ëŒ€ë¡œ Markdown, HTML, Plain Text ì¤‘ ì–´ë–¤ í˜•ì‹ì´ë“  ìƒê´€ì—†ì´ ì „í™˜í•  ë•Œë§ˆë‹¤ ê·¸ í˜•ì‹ì— ë§ê²Œ ìë™ìœ¼ë¡œ ë³€í™˜ë˜ë„ë¡ ê°œì„ í•˜ê² ìŠµë‹ˆë‹¤. ì¦‰, ì‚¬ìš©ìê°€ ì…ë ¥í•œ í…ìŠ¤íŠ¸ëŠ” ë§¤ë²ˆ í•´ë‹¹ í˜•ì‹ìœ¼ë¡œ ë³€í™˜ë˜ì–´ ë³´ì—¬ì§€ê³ , H1 íƒœê·¸ëŠ” í—ˆìš©ë˜ì§€ ì•Šê³ , ë³¸ë¬¸ê³¼ H2ë§Œ í—ˆìš©ë˜ëŠ” êµ¬ì¡°ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.

ê°œì„  ì‚¬í•­:
Markdown, HTML, ì¼ë°˜ í…ìŠ¤íŠ¸ ê°„ ìë™ ë³€í™˜:
ì‚¬ìš©ìê°€ í•œ í˜•ì‹ì—ì„œ ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œ ì „í™˜í•  ë•Œë§ˆë‹¤ ê·¸ í˜•ì‹ì— ë§ê²Œ ë³€í™˜ ë° ì¶œë ¥.
H1 íƒœê·¸ëŠ” H2ë¡œ ìë™ ë³€ê²½:
H1ì€ ì°¨ë‹¨í•˜ê³ , ìë™ìœ¼ë¡œ H2ë¡œ ë³€ê²½ë˜ë©°, ë³¸ë¬¸ê³¼ H2 íƒœê·¸ë§Œ í—ˆìš©.
ì½”ë“œ êµ¬í˜„
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import re

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ
st.subheader("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))

# ì‚¬ìš©ìê°€ ì‘ì„±í•œ í…ìŠ¤íŠ¸
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# H1ì„ H2ë¡œ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜
def convert_h1_to_h2(text):
    # HTML: <h1> íƒœê·¸ë¥¼ <h2>ë¡œ ë³€ê²½
    text = re.sub(r'<h1[^>]*>(.*?)<\/h1>', r'<h2>\1</h2>', text, flags=re.IGNORECASE)
    # Markdown: # (H1) ì„ ## (H2)ë¡œ ë³€ê²½
    text = re.sub(r'^# (.+)', r'## \1', text, flags=re.MULTILINE)
    return text

# Markdown -> HTML ë³€í™˜ í•¨ìˆ˜
def markdown_to_html(text):
    # Markdownì„ HTMLë¡œ ë³€í™˜
    text = convert_h1_to_h2(text)  # H1ì€ H2ë¡œ ë³€ê²½
    text = re.sub(r'^## (.+)', r'<h2>\1</h2>', text, flags=re.MULTILINE)  # H2 ë³€í™˜
    text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)  # Bold ì²˜ë¦¬
    return text.replace('\n', '<br>')  # ì¤„ë°”ê¿ˆì„ <br>ë¡œ ë³€í™˜

# HTML -> Markdown ë³€í™˜ í•¨ìˆ˜
def html_to_markdown(text):
    # HTMLì„ Markdownìœ¼ë¡œ ë³€í™˜
    text = convert_h1_to_h2(text)  # H1ì€ H2ë¡œ ë³€ê²½
    text = re.sub(r'<h2[^>]*>(.*?)<\/h2>', r'## \1', text, flags=re.IGNORECASE)  # H2 ë³€í™˜
    text = re.sub(r'<strong>(.*?)<\/strong>', r'**\1**', text, flags=re.IGNORECASE)  # Bold ì²˜ë¦¬
    return text.replace('<br>', '\n')  # <br> íƒœê·¸ë¥¼ ì¤„ë°”ê¿ˆìœ¼ë¡œ ë³€í™˜

# í…ìŠ¤íŠ¸ í˜•ì‹ì— ë”°ë¼ ë³€í™˜ ë° ë¯¸ë¦¬ë³´ê¸°
if text_format == "HTML":
    # ì¼ë°˜ í…ìŠ¤íŠ¸ë‚˜ Markdownì—ì„œ HTMLë¡œ ë³€í™˜
    input_text = markdown_to_html(input_text) if input_text.startswith('##') or input_text.startswith('**') else input_text
    st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
ì „ì²´ ì½”ë“œë¡œ ì œê³µí•´ì¤˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°
ChatGPTì˜ ë§:
ChatGPT
ì•„ë˜ëŠ” ìš”ì²­í•˜ì‹  ëŒ€ë¡œ Markdown, HTML, Plain Text ê°„ ìë™ ë³€í™˜ì„ êµ¬í˜„í•œ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤. ì´ ì½”ë“œëŠ” í…ìŠ¤íŠ¸ ì…ë ¥ í›„ ë²„íŠ¼ì„ í´ë¦­í•  ë•Œë§ˆë‹¤ í•´ë‹¹ í˜•ì‹ì— ë§ì¶° ë³€í™˜ëœ ë‚´ìš©ì„ í‘œì‹œí•˜ë©°, H1 íƒœê·¸ëŠ” H2ë¡œ ìë™ ë³€ê²½ë˜ëŠ” ê¸°ëŠ¥ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ì „ì²´ ì½”ë“œ:
python
ì½”ë“œ ë³µì‚¬
import streamlit as st
import re

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# ì‚¬ìš©ìê°€ ì‘ì„±í•œ í…ìŠ¤íŠ¸
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ
st.subheader("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))

# H1ì„ H2ë¡œ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜
def convert_h1_to_h2(text):
    # HTML: <h1> íƒœê·¸ë¥¼ <h2>ë¡œ ë³€ê²½
    text = re.sub(r'<h1[^>]*>(.*?)<\/h1>', r'<h2>\1</h2>', text, flags=re.IGNORECASE)
    # Markdown: # (H1) ì„ ## (H2)ë¡œ ë³€ê²½
    text = re.sub(r'^# (.+)', r'## \1', text, flags=re.MULTILINE)
    return text

# Markdown -> HTML ë³€í™˜ í•¨ìˆ˜
def markdown_to_html(text):
    # Markdownì„ HTMLë¡œ ë³€í™˜
    text = convert_h1_to_h2(text)  # H1ì€ H2ë¡œ ë³€ê²½
    text = re.sub(r'^## (.+)', r'<h2>\1</h2>', text, flags=re.MULTILINE)  # H2 ë³€í™˜
    text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)  # Bold ì²˜ë¦¬
    return text.replace('\n', '<br>')  # ì¤„ë°”ê¿ˆì„ <br>ë¡œ ë³€í™˜

# HTML -> Markdown ë³€í™˜ í•¨ìˆ˜
def html_to_markdown(text):
    # HTMLì„ Markdownìœ¼ë¡œ ë³€í™˜
ì§€ê¸ˆ ë²ˆì—­í•˜ê¸°





ë‚˜ì˜ ë§:
import streamlit as st
import pandas as pd
import requests
import re
import time
import hmac
import hashlib
import base64
import pyperclip

# í˜ì´ì§€ ë ˆì´ì•„ì›ƒì„ ë„“ê²Œ ì„¤ì •
st.set_page_config(layout="wide", page_title="ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸")

# st.secretsì—ì„œ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸°
CUSTOMER_ID = st.secrets["general"]["CUSTOMER_ID"]
API_KEY = st.secrets["general"]["API_KEY"]
SECRET_KEY = st.secrets["general"]["SECRET_KEY"]
client_id = st.secrets["general"]["client_id"]
client_secret = st.secrets["general"]["client_secret"]

# Constants
BASE_URL = "https://api.naver.com"

# í‚¤ì›Œë“œ ë¶„ì„ ê´€ë ¨ í•¨ìˆ˜
class Signature:
    @staticmethod
    def generate(timestamp, method, uri, secret_key):
        message = f"{timestamp}.{method}.{uri}"
        secret_key_bytes = bytes(secret_key, 'utf-8')
        message_bytes = bytes(message, 'utf-8')
        sign = hmac.new(secret_key_bytes, message_bytes, hashlib.sha256).digest()
        signature = base64.b64encode(sign).decode('utf-8')
        return signature

def get_request_header(method, uri):
    timestamp = str(round(time.time() * 1000))
    signature = Signature.generate(timestamp, method, uri, SECRET_KEY)
    return {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-Timestamp': timestamp,
        'X-API-KEY': API_KEY,
        'X-Customer': str(CUSTOMER_ID),
        'X-Signature': signature
    }

@st.cache_data
def get_keyword_analysis(keyword):
    uri = '/keywordstool'
    method = 'GET'
    try:
        r = requests.get(
            BASE_URL + uri,
            params={'hintKeywords': keyword, 'showDetail': 1},
            headers=get_request_header(method, uri)
        )
        r.raise_for_status()
        data = r.json()
        
        if 'keywordList' not in data:
            st.error(f"API ì‘ë‹µì— 'keywordList'ê°€ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ: {data}")
            return pd.DataFrame()
        
        df = pd.DataFrame(data['keywordList'])
        if df.empty:
            st.warning(f"'{keyword}'ì— ëŒ€í•œ í‚¤ì›Œë“œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return df
        
        # ë°ì´í„° ì²˜ë¦¬ ë¶€ë¶„ì„ try-exceptë¡œ ê°ì‹¸ ì˜¤ë¥˜ ì²˜ë¦¬
        try:
            df['monthlyMobileQcCnt'] = df['monthlyMobileQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
            df['monthlyPcQcCnt'] = df['monthlyPcQcCnt'].apply(lambda x: int(str(x).replace('<', '').strip()))
            df = df[(df['monthlyMobileQcCnt'] >= 50) & (df['monthlyPcQcCnt'] >= 50)]
            df.rename(
                {'compIdx': 'ê²½ìŸì •ë„',
                'monthlyMobileQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼',
                'monthlyPcQcCnt': 'ì›”ê°„ê²€ìƒ‰ìˆ˜_PC',
                'relKeyword': 'ì—°ê´€í‚¤ì›Œë“œ'},
                axis=1,
                inplace=True
            )
            df['ì´ê²€ìƒ‰ìˆ˜'] = df['ì›”ê°„ê²€ìƒ‰ìˆ˜_PC'] + df['ì›”ê°„ê²€ìƒ‰ìˆ˜_ëª¨ë°”ì¼']
            df = df.sort_values('ì´ê²€ìƒ‰ìˆ˜', ascending=False)
        except Exception as e:
            st.error(f"ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return pd.DataFrame()
        
        return df
    except requests.RequestException as e:
        st.error(f"API ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return pd.DataFrame()
    except Exception as e:
        st.error(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return pd.DataFrame()

# êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ
adsense_codes = {
    "êµ¬ë¼ë‹¤": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- êµ¬ë¼ë‹¤ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="5882156375"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>""",
    "ë¸”ë¡œê·¸ìŠ¤íŒŸ": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- ë¸”ë¡œê·¸ìŠ¤íŒŸ -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="9804410890"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>""",
    "ë¯¸ë¼í´E": """<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8940400388075870" crossorigin="anonymous"></script>
<!-- ë¯¸ë¼í´E -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8940400388075870"
     data-ad-slot="7074519437"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>"""
}

# ë°˜ì§ì´ëŠ” ë²„íŠ¼ HTML ìƒì„± í•¨ìˆ˜
def create_glowing_button(text, link):
    return f"""
<style>
.glow-on-hover {{
    width: 220px;
    height: 50px;
    border: none;
    outline: none;
    color: #fff;
    background: #111;
    cursor: pointer;
    position: relative;
    z-index: 0;
    border-radius: 10px;
}}
.glow-on-hover:before {{
    content: '';
    background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
    position: absolute;
    top: -2px;
    left:-2px;
    background-size: 400%;
    z-index: -1;
    filter: blur(5px);
    width: calc(100% + 4px);
    height: calc(100% + 4px);
    animation: glowing 20s linear infinite;
    opacity: 0;
    transition: opacity .3s ease-in-out;
    border-radius: 10px;
}}
.glow-on-hover:active {{
    color: #000
}}
.glow-on-hover:active:after {{
    background: transparent;
}}
.glow-on-hover:hover:before {{
    opacity: 1;
}}
.glow-on-hover:after {{
    z-index: -1;
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: #111;
    left: 0;
    top: 0;
    border-radius: 10px;
}}
@keyframes glowing {{
    0% {{ background-position: 0 0; }}
    50% {{ background-position: 400% 0; }}
    100% {{ background-position: 0 0; }}
}}
</style>
<a href="{link}" target="_blank">
    <button class="glow-on-hover" type="button">{text}</button>
</a>
"""

# ë©”ì¸ ë ˆì´ì•„ì›ƒ ì„¤ì •
st.title('ë¸”ë¡œê·¸ ì‘ì„± ë„ìš°ë¯¸')

# êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ ë²„íŠ¼
st.subheader("êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ì½”ë“œ")
for name, code in adsense_codes.items():
    if st.button(f"{name} ê´‘ê³  ì½”ë“œ ë³µì‚¬"):
        st.code(code, language='html')
        st.success(f"{name} ê´‘ê³  ì½”ë“œê°€ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”.")

# ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„±
st.subheader("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ìƒì„±")
button_text = st.text_input("ë²„íŠ¼ í…ìŠ¤íŠ¸ ì…ë ¥")
button_link = st.text_input("ë²„íŠ¼ ë§í¬ ì…ë ¥")
if st.button("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ì½”ë“œ ìƒì„±"):
    button_code = create_glowing_button(button_text, button_link)
    st.code(button_code, language='html')
    st.success("ë°˜ì§ì´ëŠ” ë²„íŠ¼ ì½”ë“œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ„ì˜ ì½”ë“œë¥¼ ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì„¸ìš”.")
    st.markdown(button_code, unsafe_allow_html=True)

# ë¸”ë¡œê·¸ ê¸€ ì‘ì„±
st.subheader("ë¸”ë¡œê·¸ ê¸€ ì‘ì„±")
text_format = st.radio("í…ìŠ¤íŠ¸ í˜•ì‹ ì„ íƒ", ("HTML", "Markdown", "ì¼ë°˜ í…ìŠ¤íŠ¸"))
input_text = st.text_area("ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”", height=300)

# í‚¤ì›Œë“œ ë¶„ì„
keywords = st.text_area('ë¶„ì„í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)', 'chatgpt, ì¸ê³µì§€ëŠ¥').split(',')
keywords_to_bold = st.text_input("êµµê²Œ í‘œì‹œí•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„)").split(',')

# ì´ëª¨í‹°ì½˜ ì¶”ê°€ ë²„íŠ¼
emoji_list = [("ğŸ˜€", "ğŸ˜€"), ("ğŸ˜‚", "ğŸ˜‚"), ("ğŸ˜", "ğŸ˜"), ("ğŸ‘", "ğŸ‘"), ("ğŸ‰", "ğŸ‰")]
cols = st.columns(len(emoji_list))
for idx, (emoji, emoji_symbol) in enumerate(emoji_list):
    with cols[idx]:
        if st.button(emoji):
            input_text += emoji_symbol
            st.experimental_rerun()

# í‚¤ì›Œë“œ ê°•ì¡° ê¸°ëŠ¥
if text_format == "HTML":
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'<strong>\1</strong>', input_text)
elif text_format == "Markdown":
    for keyword in keywords_to_bold:
        keyword = keyword.strip()
        if keyword:
            input_text = re.sub(r'({})'.format(re.escape(keyword)), r'**\1**', input_text)

# ì‘ì„±ëœ ê¸€ ë¯¸ë¦¬ë³´ê¸°
st.subheader("ì‘ì„±ëœ ë¸”ë¡œê·¸ ê¸€ ë¯¸ë¦¬ ë³´ê¸°:")
if text_format == "HTML":
    st.markdown(input_text, unsafe_allow_html=True)
elif text_format == "Markdown":
    st.markdown(input_text)
else:
    st.text(input_text)

# í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼
st.subheader("í‚¤ì›Œë“œ ë¶„ì„ ê²°ê³¼")
if st.button('ë¶„ì„ ì‹¤í–‰'):
    tmp_df = pd.DataFrame()
    with st.spinner('í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...'):
        for keyword in keywords:
            keyword = keyword.strip()
            if keyword:
                df = get_keyword_analysis(keyword)
                if not df.empty:
                    tmp_df = pd.concat([tmp_df, df], axis=0)
    if not tmp_df.empty:
        st.dataframe(tmp_df)
    else:
        st.warning("ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. í‚¤ì›Œë“œë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.") 
